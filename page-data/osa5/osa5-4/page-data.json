{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa5/osa5-4",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Oliot ja viittaukset\",\n  \"nav_order\": 4,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Jatketaan olioiden ja viittausten parissa. Oletetaan, ett\\xE4 voimme k\\xE4ytt\\xE4\\xE4 henkil\\xF6\\xE4 kuvaavaa luokkaa, joka on esitetty alla.\"), mdx(\"p\", null, \"Person-oliolla on oliomuuttujat name, age, weight ja height. Lis\\xE4ksi sill\\xE4 on metodeja, joiden avulla voidaan laskea painoindeksi ym. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n\\n  public class Person\\n  {\\n    private string name;\\n    private int age;\\n    private int weight;\\n    private int height;\\n\\n    // Konstruktori, jossa vain nimi\\n    public Person(string name) : this(name, 0, 0, 0)\\n    {\\n    }\\n\\n    // Konstruktori, jossa nimi ja ik\\xE4\\n    public Person(string name, int age) :this(name, age, 0, 0)\\n    {\\n    }\\n\\n    // Konstruktori, jossa nimi, ik\\xE4, paino ja pituus\\n    // Ylemm\\xE4t konstruktorit kutsuvat t\\xE4t\\xE4\\n    public Person(string name, int age, int weight, int height)\\n    {\\n      this.name = name;\\n      this.age = age;\\n      this.weight = weight;\\n      this.height = height;\\n    }\\n\\n    public double BodyMassIndex()\\n    {\\n      double heigthPerHundred = this.height / 100.0;\\n      return this.weight / (heigthPerHundred * heigthPerHundred);\\n    }\\n\\n    public double MaximumHeartRate()\\n    {\\n      return 206.3 - (0.711 * this.age);\\n    }\\n    \\n    public bool IsAdult()\\n    {\\n      if (this.age < 18)\\n      {\\n        return false;\\n      }\\n      return true;\\n    }\\n\\n    public void GrowOlder()\\n    {\\n      this.GrowOlder(1);\\n    }\\n\\n    public void GrowOlder(int years)\\n    {\\n      this.age += years;\\n    }\\n\\n    public override string ToString()\\n    {\\n      return this.name + \\\", age \\\" + this.age + \\\" years\\\";\\n    }\\n\\n\\n  }\\n}\\n\")), mdx(\"p\", null, \"Mit\\xE4 tarkalleenottaen tapahtuu, kun uusi olio luodaan?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person joan = new Person(\\\"Joan Ball\\\");\\n\")), mdx(\"p\", null, \"Konstruktorin kutsu komennolla \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"new\"), \" aiheuttaa useita asioita. \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ensin varataan tilaa tietokoneen muistista oliomuuttujien s\\xE4ilytt\\xE4miseen.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sitten oliomuuttujille asetetaan alku- tai oletusarvot (esim. int-tyyppinen muuttuja saa alkuarvokseen 0).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lopulta suoritetaan konstruktorin koodi.\")), mdx(\"p\", null, \"Konstruktorikutsu palauttaa viitteen olioon. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Viite\"), \" on tietoa oliomuuttujien sijainnista.\"), mdx(\"p\", null, \"Eli muuttujan arvo asetetaan viitteeksi, eli tiedoksi siihen liittyv\\xE4n olion sijainnista. Merkkijonot -- esimerkiksi henkil\\xF6n nimi -- ovat my\\xF6s olioita.\"), mdx(\"h2\", {\n    \"id\": \"viittausmuuttujan-asettaminen-kopioi-viitteen\"\n  }, \"Viittausmuuttujan asettaminen kopioi viitteen\"), mdx(\"p\", null, \"Luodaan Person-olio nimelt\\xE4\\xE4n \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ball\"), \" ohjelmassa, ja asetetaan sille alkuarvoksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"joan\"), \"-muuttujan arvo. Mit\\xE4 tapahtuu?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person joan = new Person(\\\"Joan Ball\\\");\\nConsole.WriteLine(joan);\\n\\nPerson ball = joan;\\n\")), mdx(\"p\", null, \"Lauseke \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person ball = joan;\"), \" luo uuden Person-tyyppisen muuttujan, ja kopioi muuttujan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"joan\"), \" arvon. T\\xE4m\\xE4n seurauksena \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ball\"), \" viittaa samaan olioon kuin \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"joan\"), \".\"), mdx(\"p\", null, \"Tarkastellaan esimerkki\\xE4 tarkemmin.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person joan = new Person(\\\"Joan Ball\\\");\\nConsole.WriteLine(joan);\\n\\nPerson ball = joan;\\nball.GrowOlder();\\nball.GrowOlder();\\n\\nConsole.WriteLine(joan);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Joan Ball, age: 0\\nJoan Ball, age: 2\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Joan Ball\"), \" eli Person-olio johon \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"joan\"), \"-muuttuja viittaa, on aluksi 0-vuotias. T\\xE4m\\xE4n j\\xE4lkeen \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"joan\"), \"-muuttujan arvo kopioidaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ball\"), \"-muuttujan arvoksi. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person-olio ball\"), \" vanhenee kahdella vuodella, ja Joan Ball vanhenee samalla!\"), mdx(\"p\", null, \"Olion sis\\xE4ist\\xE4 tilaa ei kopioda, kun muuttujan arvoa asetetaan. Lausekkeessa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person ball = joan;\"), \" ei luoda uutta oliota -- muuttujan arvoa asetetaan kopioimalla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"joan\"), \"-muuttujan arvo, eli viite olioon.\"), mdx(\"p\", null, \"Seuraavaksi esimerkki\\xE4 jatketaan niin, ett\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"joan\"), \"-muuttujalle luodaan uusi olio, ja viite siihen asetetaan muuttujan arvoksi. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ball\"), \"-muuttuja viittaa edelleen aiempaan olioon.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person joan = new Person(\\\"Joan Ball\\\");\\nConsole.WriteLine(joan);\\n\\nPerson ball = joan;\\nball.GrowOlder();\\nball.GrowOlder();\\n\\nConsole.WriteLine(joan);\\n\\njoan = new Person(\\\"Joan B.\\\");\\nConsole.WriteLine(joan);\\n\")), mdx(\"p\", null, \"The following is printed:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Joan Ball, age: 0\\nJoan Ball, age: 2\\nJoan B., age: 0\\n\")), mdx(\"p\", null, \"Joten alussa muuttuja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"joan\"), \" viittaa yhteen olioon, mutta lopussa sen arvoksi on kopioitu toisen olion viite.\"), mdx(\"h2\", {\n    \"id\": \"viittausmuuttujan-arvo-voi-olla-null\"\n  }, \"Viittausmuuttujan arvo voi olla null\"), mdx(\"p\", null, \"Laajennetaan esimerkki\\xE4 viel\\xE4 niin, ett\\xE4 viittausmuuttujan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ball\"), \" arvoksi asetetaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \", eli viite \\\"ei mihink\\xE4\\xE4n\\\". \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \"-viite voidaan asettaa mink\\xE4 tahansa viittaustyyppisen muuttujan arvoksi.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person joan = new Person(\\\"Joan Ball\\\");\\nConsole.WriteLine(joan);\\n\\nPerson ball = joan;\\nball.GrowOlder();\\nball.GrowOlder();\\n\\nConsole.WriteLine(joan);\\n\\njoan = new Person(\\\"Joan B.\\\");\\nConsole.WriteLine(joan);\\n\\nball = null;\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Joan Ball, age: 0\\nJoan Ball, age: 2\\nJoan B., age: 0\\n\")), mdx(\"p\", null, \"Olioon, jonka nimi on Joan Ball, ei viittaa kukaan. Toisin sanoen olio on \\\"roskaa\\\". Roskien ker\\xE4\\xE4j\\xE4 (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"garbage collector\"), \") huolehtii sovelluksesi muistin varauksesta ja vapauttamisesta. \"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"C# dokumentaatio roskien ker\\xE4\\xE4misest\\xE4 kertoo seuraavaa\")), \":\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"Each time you create a new object, the common language runtime allocates memory for the object from the managed heap. As long as address space is available in the managed heap, the runtime continues to allocate space for new objects.\"), \" \"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"However, memory is not infinite. Eventually the garbage collector must perform a collection in order to free some memory.  If the garbage collection did not happen, the garbage objects would reserve a memory location until the end of the program execution.\\\"\")), mdx(\"p\", null, \"Toisin sanottuna, kun olio ei ole en\\xE4\\xE4 tarpeen, siit\\xE4 huolehditaan, joten muistitila on k\\xE4ytett\\xE4viss\\xE4 muuhun k\\xE4ytt\\xF6\\xF6n.\"), mdx(\"p\", null, \"Katsotaan viel\\xE4, mit\\xE4 tapahtuu, kun yritet\\xE4\\xE4n tulostaa viittausmuuttujan arvo, joka viittaa \\\"ei mihink\\xE4\\xE4n\\\".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person joan = new Person(\\\"Joan Ball\\\");\\nConsole.WriteLine(joan);\\n\\nPerson ball = joan;\\nball.GrowOlder();\\nball.GrowOlder();\\n\\nConsole.WriteLine(joan);\\n\\njoan = new Person(\\\"Joan B.\\\");\\nConsole.WriteLine(joan);\\n\\nball = null;\\nConsole.WriteLine(ball);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Joan Ball, age: 0\\nJoan Ball, age: 2\\nJoan B., age: 0\\n\\n\")), mdx(\"p\", null, \"Emme n\\xE4e mit\\xE4\\xE4n tulostusta viimeisell\\xE4 tulostusk\\xE4skyll\\xE4: se johtuu siit\\xE4, ett\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ball\"), \" viittaa nyt \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \"-arvoon, eli \\\"ei mihink\\xE4\\xE4n\\\".\"), mdx(\"p\", null, \"Katsotaan mit\\xE4 tapahtuu jos yrit\\xE4mme kasvattaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ball\"), \"-muuttujan ik\\xE4\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person joan = new Person(\\\"Joan Ball\\\");\\nConsole.WriteLine(joan);\\n\\nPerson ball = joan;\\nball.GrowOlder();\\nball.GrowOlder();\\n\\nConsole.WriteLine(joan);\\n\\njoan = new Person(\\\"Joan B.\\\");\\nConsole.WriteLine(joan);\\n\\nball = null;\\nConsole.WriteLine(ball);\\nball.GrowOlder();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Joan Ball, age: 0\\nJoan Ball, age: 2\\nJoan B., age: 0\\n\\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\\n    in /.../src/Exercise001/Program.cs:line 24\\n\")), mdx(\"p\", null, \"Pahoja asioita tapahtuu. Saamme \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NullReferenceException\"), \"-virheen. Virheen nimi on itsest\\xE4\\xE4n selv\\xE4 (niin kuin virheiden pit\\xE4\\xE4kin olla). Ohjelman suorituksen aikana tapahtui virhe, joka viittaa siihen, ett\\xE4 kutsuimme metodia muuttujalla, joka viittaa \\\"ei mihink\\xE4\\xE4n\\\".\"), mdx(\"p\", null, \"Lupaan, ettei t\\xE4m\\xE4 ole viimeinen kerta, kun t\\xF6rm\\xE4\\xE4t edelliseen virheeseen. Kun t\\xF6rm\\xE4\\xE4t, ensimm\\xE4inen askel on etsi\\xE4 muuttujia, joiden arvo voi olla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"null\"), \". Onneksi virheilmoitus on hy\\xF6dyllinen: se kertoo, mik\\xE4 rivi aiheutti virheen. Kokeile itse!\"), mdx(\"h2\", {\n    \"id\": \"olio-metodin-parametrina\"\n  }, \"Olio metodin parametrina\"), mdx(\"p\", null, \"Olemme n\\xE4hneet sek\\xE4 arvo- ett\\xE4 viittausmuuttujien toimivan metodin parametreina. Koska oliot ovat viittausmuuttujia, mik\\xE4 tahansa olio voidaan m\\xE4\\xE4ritell\\xE4 metodin parametriksi. Katsotaan k\\xE4yt\\xE4nn\\xF6n esimerkki.\"), mdx(\"p\", null, \"Huvipuiston laitteet p\\xE4\\xE4st\\xE4v\\xE4t vain tietyn pituiset ihmiset laitteisiin. Rajoite ei ole kaikissa laitteissa sama. Luodaan luokka, joka kuvaa huvipuistolaitetta. Kun luodaan uusi olio, konstruktori saa parametreina laitteen nimen ja pienimm\\xE4n sallitun pituuden.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class AmusementParkRide\\n{\\n  private string name;\\n  private int lowestHeight;\\n\\n  public AmusementParkRide(string name, int lowestHeight)\\n  {\\n    this.name = name;\\n    this.lowestHeight = lowestHeight;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.name + \\\", minimum height: \\\" + this.lowestHeight;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Kirjoitetaan viel\\xE4 metodi jota voimme k\\xE4ytt\\xE4\\xE4 tarkistamaan, onko henkil\\xF6 laitteeseen p\\xE4\\xE4syn ik\\xE4inen, eli onko h\\xE4n tarpeeksi pitk\\xE4. Metodi palauttaa true, jos parametrina annettu henkil\\xF6 saa menn\\xE4 laitteeseen, ja false muuten.\"), mdx(\"p\", null, \"Voimme olettaa ett\\xE4 henkil\\xF6ll\\xE4 on my\\xF6s ominaisuus kertoa ik\\xE4 luokan ulkopuolelle (eli muuttuja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"int age\"), \" on public).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public bool AllowedToRide(Person person)\\n{\\n  if (person.height < this.lowestHeight)\\n  {\\n    return false;\\n  }\\n\\n  return true;\\n}\\n\")), mdx(\"p\", null, \"Joten AmusementParkRide-olion metodi AllowedToRide saa parametrina Person-olion. Kuten aiemmin, muuttujan arvo -- t\\xE4ss\\xE4 tapauksessa viite -- kopioidaan metodin k\\xE4ytt\\xF6\\xF6n. Metodi k\\xE4sittelee kopioitua viitett\\xE4, ja kutsuu parametrina annetun person-olion age-muuttujaa.\"), mdx(\"p\", null, \"Alla esimerkki p\\xE4\\xE4ohjelmasta, jossa huvipuistolaitteen metodia kutsutaan kahdesti: ensin parametrina on person-olio \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"matt\"), \", ja sitten person-olio \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"jasper\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n\\n  // Konstruktorilla on nimi, ik\\xE4, paino ja pituus\\n  Person matt = new Person(\\\"Matt\\\", 15, 86, 180);\\n\\n  Person jasper = new Person(\\\"Jasper\\\", 8, 34, 132);\\n\\n  AmusementParkRide waterTrack = new AmusementParkRide(\\\"Water track\\\", 140);\\n\\n  if (waterTrack.AllowedToRide(matt))\\n  {\\n    Console.WriteLine(matt.name + \\\" may enter the ride\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(matt.name + \\\" may not enter the ride\\\");\\n  }\\n\\n  if (waterTrack.AllowedToRide(jasper))\\n  {\\n    Console.WriteLine(jasper.name + \\\" may enter the ride\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(jasper.name + \\\" may not enter the ride\\\");\\n  }\\n\\n  Console.WriteLine(waterTrack);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Matt may enter the ride\\nJasper may not enter the ride\\nWater track, minimum height: 140\\n\")), mdx(\"p\", null, \"Ent\\xE4 jos haluaisimme tiet\\xE4\\xE4, kuinka monta ihmist\\xE4 on k\\xE4ynyt laitteessa?\"), mdx(\"p\", null, \"Lis\\xE4t\\xE4\\xE4n huvipuistolaitteeseen oliomuuttuja, joka pit\\xE4\\xE4 kirjaa laitteeseen p\\xE4\\xE4sseiden ihmisten m\\xE4\\xE4r\\xE4st\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class AmusementParkRide\\n{\\n  private string name;\\n  private int lowestHeight;\\n  private int visitors;\\n\\n  public AmusementParkRide(string name, int lowestHeight)\\n  {\\n    this.name = name;\\n    this.lowestHeight = lowestHeight;\\n    this.visitors = 0;\\n  }\\n\\n  public bool AllowedToRide(Person person)\\n  {\\n    if (person.height < this.lowestHeight)\\n    {\\n      return false;\\n    }\\n    this.visitors++;\\n    return true;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.name + \\\", minimum height: \\\" + this.lowestHeight +\\n            \\\", visitors: \\\" + this.visitors;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Nyt aiemmin k\\xE4ytetty esimerkkiohjelma pit\\xE4\\xE4 kirjaa my\\xF6s siit\\xE4, kuinka monta ihmist\\xE4 on k\\xE4ynyt laitteessa.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n\\n  // Our constructor has name, age, weight, height\\n  Person matt = new Person(\\\"Matt\\\", 15, 86, 180);\\n\\n  Person jasper = new Person(\\\"Jasper\\\", 8, 34, 132);\\n\\n  AmusementParkRide waterTrack = new AmusementParkRide(\\\"Water track\\\", 140);\\n\\n  if (waterTrack.AllowedToRide(matt))\\n  {\\n    Console.WriteLine(matt.name + \\\" may enter the ride\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(matt.name + \\\" may not enter the ride\\\");\\n  }\\n\\n  if (waterTrack.AllowedToRide(jasper))\\n  {\\n    Console.WriteLine(jasper.name + \\\" may enter the ride\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(jasper.name + \\\" may not enter the ride\\\");\\n  }\\n\\n  Console.WriteLine(waterTrack);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Matt may enter the ride\\nJasper may not enter the ride\\nWater track, minimum height: 140, visitors: 1\\n\")), mdx(\"h2\", {\n    \"id\": \"olio-oliomuuttujana\"\n  }, \"Olio oliomuuttujana\"), mdx(\"p\", null, \"Oliolla voi olla viittauksia olioihin.\"), mdx(\"p\", null, \"Jatketaan ty\\xF6skentely\\xE4 ihmisten parissa, ja lis\\xE4t\\xE4\\xE4n Person-luokkaan syntym\\xE4p\\xE4iv\\xE4. Luonnollinen tapa ilmaista syntym\\xE4p\\xE4iv\\xE4\\xE4 on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Date\"), \" luokka. Voisimme k\\xE4ytt\\xE4\\xE4 luokan nime\\xE4 Date, mutta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"v\\xE4ltt\\xE4\\xE4ksemme sekaannuksen C#-kielen valmiin Date-luokan kanssa\"), \", k\\xE4yt\\xE4mme t\\xE4ss\\xE4 omaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SimpleDate\"), \"-luokkaa.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class SimpleDate\\n{\\n  private int day;\\n  private int month;\\n  private int year;\\n\\n  public SimpleDate(int day, int month, int year)\\n  {\\n    this.day = day;\\n    this.month = month;\\n    this.year = year;\\n  }\\n\\n\\n  public override string ToString()\\n  {\\n    return this.day + \\\".\\\" + this.month + \\\".\\\" + this.year;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Koska tied\\xE4mme syntym\\xE4p\\xE4iv\\xE4n, ei ole tarpeen s\\xE4ilytt\\xE4\\xE4 henkil\\xF6n ik\\xE4\\xE4 erillisen\\xE4 oliomuuttujana. Henkil\\xF6n ik\\xE4 voidaan p\\xE4\\xE4tell\\xE4 syntym\\xE4p\\xE4iv\\xE4st\\xE4. Oletetaan, ett\\xE4 Person-luokalla on nyt seuraavat oliomuuttujat.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person\\n{\\n  public string name;\\n  private SimpleDate birthday;\\n  private int weight;\\n  public int height;\\n\\n//  ...\\n}\\n\")), mdx(\"p\", null, \"Luodaan uusi Person-konstruktori, joka mahdollistaa syntym\\xE4p\\xE4iv\\xE4n asettamisen:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public Person(string name, SimpleDate date)\\n{\\n  this.name = name;\\n  this.birthday = date;\\n  this.weight = 0;\\n  this.height = 0;\\n}\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4n lis\\xE4ksi voisimme antaa Person-luokalle toisen konstruktorin, jossa syntym\\xE4p\\xE4iv\\xE4 annetaan kokonaislukuina.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public Person(string name, int day, int month, int year)\\n{\\n  this.name = name;\\n  this.birthday = new SimpleDate(day, month, year);\\n}\\n\")), mdx(\"p\", null, \"Konstruktori ottaa parametreina p\\xE4iv\\xE4n, kuukauden ja vuoden, ja luo niiden perusteella uuden SimpleDate-olion. T\\xE4m\\xE4n j\\xE4lkeen se asettaa viitteen olion birthday-muuttujaan.\"), mdx(\"p\", null, \"Muokataan my\\xF6s ToString-metodia, jotta se palauttaa syntym\\xE4p\\xE4iv\\xE4n i\\xE4n sijaan:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override string ToString()\\n{\\n  return this.name + \\\", born on \\\" + this.birthday;\\n}\\n\")), mdx(\"p\", null, \"Katsotaan miten p\\xE4ivitetty Person-luokka toimii.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"SimpleDate date = new SimpleDate(1, 1, 780);\\nPerson muhammad = new Person(\\\"Muhammad ibn Musa al-Khwarizmi\\\", date);\\nPerson pascal = new Person(\\\"Blaise Pascal\\\", 19, 6, 1623);\\n\\nConsole.WriteLine(muhammad);\\nConsole.WriteLine(pascal);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Muhammad ibn Musa al-Khwarizmi, born on 1.1.780\\nBlaise Pascal, born on 19.6.1623\\n\")), mdx(\"p\", null, \"Nyt Person-oliolla on muuttujat nimi ja syntym\\xE4p\\xE4iv\\xE4. Muuttuja nimi on merkkijono, joka on itsekin olio; muuttuja syntym\\xE4p\\xE4iv\\xE4 on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"SimpleDate-olio\"), \".\"), mdx(\"p\", null, \"Molemmat muuttujat sis\\xE4lt\\xE4v\\xE4t viitteen olioon. T\\xE4m\\xE4n seurauksena Person-oliossa on kaksi viitett\\xE4.\"), mdx(\"p\", null, \"Eli Main-metodi sis\\xE4lt\\xE4\\xE4 kaksi viitett\\xE4 Person-olioihin, ja jokainen Person-olio sis\\xE4lt\\xE4\\xE4 kaksi viitett\\xE4: nimi-merkkijonoon ja syntym\\xE4p\\xE4iv\\xE4-olioon.\"), mdx(\"p\", null, \"Syntym\\xE4p\\xE4iv\\xE4 vaikuttaa hyv\\xE4lt\\xE4 laajennukselta Person-luokalle. Aiemmin huomasimme, ett\\xE4 henkil\\xF6n ik\\xE4 voidaan laskea syntym\\xE4p\\xE4iv\\xE4n perusteella. T\\xE4m\\xE4n seurauksena ik\\xE4-muuttuja voidaan poistaa.\"), mdx(\"p\", null, \"Yll\\xE4 olevassa osiossa k\\xE4ytimme omaa SimpleDate-luokkaa p\\xE4iv\\xE4m\\xE4\\xE4rien k\\xE4sittelyyn, koska se sopii hyvin olioiden toiminnan esittelyyn ja harjoitteluun. Jos haluamme k\\xE4sitell\\xE4 p\\xE4iv\\xE4m\\xE4\\xE4ri\\xE4 (ja aikaa) omassa ohjelmassamme, k\\xE4ytt\\xE4isimme todenn\\xE4k\\xF6isesti \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"hhttps://learn.microsoft.com/en-us/dotnet/api/system.datetime?view=net-6.0\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"C#:n DateTime\")), \" -luokkaa emmek\\xE4 kirjoittaisi omaa versiota.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"DateTime now = DateTime.Now;\\nConsole.WriteLine(now);\\nint year = now.Year;\\nint month = now.Month;\\nint day = now.Day;\\n\\nConsole.WriteLine(\\\"today is  \\\" + day + \\\".\\\" + month + \\\".\\\" + year);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"2/13/2020 7:12:07 PM\\ntoday is  13.2.2020\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"C#:lla ensimm\\xE4inen rivi voi olla erilainen, riippuen k\\xE4ytt\\xF6j\\xE4rjestelm\\xE4st\\xE4 ja kieliasetuksista. T\\xE4m\\xE4 johtuu kulttuurista C#-ymp\\xE4rist\\xF6iss\\xE4. K\\xE4sittelemme t\\xE4t\\xE4 my\\xF6hemmin.\"), mdx(\"h2\", {\n    \"id\": \"samantyyppinen-olio-metodin-parametrina\"\n  }, \"Samantyyppinen olio metodin parametrina\"), mdx(\"p\", null, \"Jatkamme edelleen ihmisten parissa. Henkil\\xF6 tiet\\xE4\\xE4 edelleen syntym\\xE4p\\xE4iv\\xE4ns\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person\\n{\\n  public string name;\\n  private SimpleDate birthday;\\n  private int weight;\\n  public int height;\\n  \\n// ...\\n\")), mdx(\"p\", null, \"Haluaisimme vertailla kahden henkil\\xF6n ik\\xE4\\xE4. Vertailu voidaan tehd\\xE4 monella tapaa. Voisimme esimerkiksi toteuttaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public int AgeAsYears()\"), \" -metodin Person-luokkaan, joka palauttaa henkil\\xF6n i\\xE4n vuosina. Vertailu voitaisiin toteuttaa seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person muhammad = new Person(\\\"Muhammad ibn Musa al-Khwarizmi\\\", 1, 1, 780);\\nPerson pascal = new Person(\\\"Blaise Pascal\\\", 19, 6, 1623);\\n\\nif (muhammad.AgeAsYears() > pascal.AgeAsYears()) {\\n    Console.WriteLine(muhammad.name + \\\" is older than \\\" + pascal.name);\\n}\\n\")), mdx(\"p\", null, \"Opiskelemme nyt kuitenkin \\\"olio-ohjelmoinnin\\\" tavan vertailla henkil\\xF6iden ik\\xE4\\xE4. Luomme uuden metodin \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public bool OlderThan(Person compared)\"), \" Person-luokkaan. \"), mdx(\"p\", null, \"Sit\\xE4 voidaan k\\xE4ytt\\xE4\\xE4 vertailemaan tietyn henkil\\xF6n ik\\xE4\\xE4 toiseen henkil\\xF6\\xF6n verrattuna. Metodi on tarkoitettu k\\xE4ytett\\xE4v\\xE4ksi seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Person muhammad = new Person(\\\"Muhammad ibn Musa al-Khwarizmi\\\", 1, 1, 780);\\nPerson pascal = new Person(\\\"Blaise Pascal\\\", 19, 6, 1623);\\n\\nif (muhammad.OlderThan(pascal)) {  //  sama kuin muhammad.OlderThan(pascal)==true\\n    Console.WriteLine(muhammad.name + \\\" is older than \\\" + pascal.name);\\n} else {\\n    Console.WriteLine(muhammad.name + \\\" is not older than \\\" + pascal.name);\\n}\\n\")), mdx(\"p\", null, \"Yll\\xE4 oleva ohjelma kertoo, onko Muhammad al-Khwarizmi vanhempi kuin Blaise Pascal. Metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"OlderThan\"), \" palauttaa true, jos sit\\xE4 kutsuvan olion ik\\xE4 on suurempi kuin parametrina annetun olion ik\\xE4. Muussa tapauksessa se palauttaa false.\"), mdx(\"p\", null, \"K\\xE4yt\\xE4nn\\xF6ss\\xE4, kutsutaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"OlderThan\"), \"-metodia oliolla, joka vastaa \\\"Muhammad ibn Musa al-Khwarizmi\\\", joka viitataan muuttujalla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"muhammad\"), \". Viite \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"pascal\"), \", joka vastaa oliota \\\"Blaise Pascal\\\", annetaan parametrina tuolle metodille.\"), mdx(\"p\", null, \"Ohjelma tulostaa:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Muhammad ibn Musa al-Khwarizmi is older than Blaise Pascal\\n\")), mdx(\"p\", null, \"Metodi OlderThan saa parametrina Person-olion. Tarkemmin sanottuna muuttuja, joka on m\\xE4\\xE4ritelty metodin parametriksi, saa kopion parametrina annetun muuttujan arvosta. T\\xE4m\\xE4 arvo on viite olioon, t\\xE4ss\\xE4 tapauksessa Person-olioon.\"), mdx(\"p\", null, \"Metodin toteutus on kuvattu alla. Huomaa, ett\\xE4 metodi voi palauttaa arvon useammassa kuin yhdess\\xE4 kohdassa -- t\\xE4ss\\xE4 vertailu on jaettu useampaan osaan vuosien, kuukausien ja p\\xE4ivien perusteella:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public bool OlderThan(Person compared)\\n{\\n  // 1. Vertaa ensin iki\\xE4\\n  int ownYear = this.birthday.year;\\n  int comparedYear = compared.birthday.year;\\n\\n  if (ownYear < comparedYear)\\n  {\\n    return true;\\n  }\\n\\n  if (ownYear > comparedYear)\\n  {\\n    return false;\\n  }\\n\\n  // 2. Jos vuodet samat, vertaa kuukausia\\n  int ownMonth = this.birthday.month;\\n  int comparedMonth = compared.birthday.month;\\n\\n  if (ownMonth < comparedMonth)\\n  {\\n    return true;\\n  }\\n\\n  if (ownMonth > comparedMonth)\\n  {\\n    return false;\\n  }\\n\\n  // 3. Jos vuodet ja kuukaudet samat, vertaa p\\xE4ivi\\xE4\\n  int ownDay = this.birthday.day;\\n  int comparedDay = compared.birthday.day;\\n\\n  if (ownDay < comparedDay)\\n  {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n\")), mdx(\"p\", null, \"Pys\\xE4hdyt\\xE4\\xE4n hetkeksi miettim\\xE4\\xE4n abstraktiota, joka on yksi olioperustaisen ohjelmoinnin periaatteista. Abstraktion ideana on konseptualisoida ohjelmakoodi niin, ett\\xE4 jokaisella konseptilla on omat selke\\xE4t vastuunsa. Katsomalla yll\\xE4 olevaa ratkaisua huomaamme, ett\\xE4 vertailutoiminnallisuus olisi parempi sijoittaa SimpleDate-luokan sis\\xE4lle Person-luokan sijaan.\"), mdx(\"p\", null, \"Luodaan metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public bool Before(SimpleDate compared)\"), \" luokkaan SimpleDate. Metodi palauttaa arvon true, jos parametrina annettu p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4 on my\\xF6hempi (tai sama) kuin kutsuvan olion p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4. Muussa tapauksessa se palauttaa arvon false.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class SimpleDate\\n{\\n  private int day;\\n  private int month;\\n  private int year;\\n\\n  public SimpleDate(int day, int month, int year)\\n  {\\n    this.day = day;\\n    this.month = month;\\n    this.year = year;\\n  }\\n\\n\\n  public override string ToString()\\n  {\\n    return this.day + \\\".\\\" + this.month + \\\".\\\" + this.year;\\n  }\\n\\n  // tarkistetaan onko kutsuvan (this) p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4 ennen \\n  // parametrina annettua p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4\\xE4 (compared)\\n  public bool Before(SimpleDate compared)\\n  {\\n    // vertaa ensin vuosia\\n    if (this.year < compared.year)\\n    {\\n      return true;\\n    }\\n\\n    if (this.year > compared.year)\\n    {\\n      return false;\\n    }\\n\\n    // sama vuosi, vertaa kuukausia\\n    if (this.month < compared.month)\\n    {\\n      return true;\\n    }\\n\\n    if (this.month > compared.month)\\n    {\\n      return false;\\n    }\\n\\n    // vuodet ja kuukaudet samat, vertaa p\\xE4ivi\\xE4\\n    if (this.day < compared.day)\\n    {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Vaikka objektin muuttujat year, month ja day ovat kapsuloitu (private) oliomuuttujia, voimme lukea niiden arvoja kirjoittamalla compared.\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"muuttujanNimi\"), \". T\\xE4m\\xE4 johtuu siit\\xE4, ett\\xE4 private-muuttujat ovat luokan kaikkien metodien k\\xE4ytett\\xE4viss\\xE4. Huomaa, ett\\xE4 syntaksissa kutsutaan oliomuuttujia, ei metodeja. Toisin kuin metodia kutsuttuaessa, nyt viittaus on oliomuuttujaan, joten sulkumerkkej\\xE4, jotka ilmaisevat metodikutsua, ei kirjoiteta.\"), mdx(\"p\", null, \"Esimerkki metodin k\\xE4yt\\xF6st\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"SimpleDate d1 = new SimpleDate(14, 2, 2011);\\nSimpleDate d2 = new SimpleDate(21, 2, 2011);\\nSimpleDate d3 = new SimpleDate(1, 3, 2011);\\nSimpleDate d4 = new SimpleDate(31, 12, 2010);\\n\\nConsole.WriteLine(d1 + \\\" is earlier than \\\" + d2 + \\\": \\\" + d1.Before(d2));\\nConsole.WriteLine(d2 + \\\" is earlier than \\\" + d1 + \\\": \\\" + d2.Before(d1));\\n\\nConsole.WriteLine(d2 + \\\" is earlier than \\\" + d3 + \\\": \\\" + d2.Before(d3));\\nConsole.WriteLine(d3 + \\\" is earlier than \\\" + d2 + \\\": \\\" + d3.Before(d2));\\n\\nConsole.WriteLine(d4 + \\\" is earlier than \\\" + d1 + \\\": \\\" + d4.Before(d1));\\nConsole.WriteLine(d1 + \\\" is earlier than \\\" + d4 + \\\": \\\" + d1.Before(d4));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"14.2.2011 is earlier than 21.2.2011: True\\n21.2.2011 is earlier than 14.2.2011: False\\n21.2.2011 is earlier than 1.3.2011: True\\n1.3.2011 is earlier than 21.2.2011: False\\n31.12.2010 is earlier than 14.2.2011: True\\n14.2.2011 is earlier than 31.12.2010: False\\n\")), mdx(\"p\", null, \"Parannetaan OlderThan-metodia, siten ett\\xE4 jatkossa se k\\xE4ytt\\xE4\\xE4 SimpleDate-luokan vertailutoimintoa.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public bool OlderThan(Person compared) {\\n    if (this.birthday.Before(compared.birthday)) {\\n        return true;\\n    }\\n\\n    return false;\\n\\n    // or return more directly:\\n    // return this.birthday.Before(compared.birthday);\\n}\\n\")), mdx(\"p\", null, \"Nyt p\\xE4iv\\xE4m\\xE4\\xE4rien konkreettinen vertailu on toteutettu luokassa, johon se loogisesti kuuluu (perustuen luokkien nimiin).\"), mdx(\"h2\", {\n    \"id\": \"yhdenvertaisuus-equality\"\n  }, \"Yhdenvertaisuus (Equality)\"), mdx(\"p\", null, \"Jos haluamme vertailla kahta itsesuunnittelemaamme oliota, p\\xE4\\xE4asiassa haluamme k\\xE4ytt\\xE4\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" -metodia, joka t\\xE4ytyy siis m\\xE4\\xE4ritell\\xE4 luokassa itsess\\xE4\\xE4n. Metodi Equals on m\\xE4\\xE4ritelty palauttamaan boolean-tyyppinen arvo -- paluuarvo kertoo, ovatko oliot yht\\xE4l\\xE4iset.\"), mdx(\"p\", null, \"Equals-metodi toteutetaan siten, ett\\xE4 sen avulla voidaan vertailla kyseist\\xE4 objektia mihin tahansa toiseen objektiin. Metodi saa parametrina \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Object\"), \" -tyyppisen objektin, joka on kaikkien objektien yl\\xE4luokka, eli kaikki objektit/oliot ovat tyyppi\\xE4 Object oman tyyppins\\xE4 lis\\xE4ksi. Ensin vertailemme objektien osoitteita: jos osoitteet ovat samat, ovat oliot samat. T\\xE4m\\xE4n j\\xE4lkeen tarkistamme, ovatko objektien tyypit samat: jos eiv\\xE4t ole, ovat oliot erilaiset. T\\xE4m\\xE4n j\\xE4lkeen muunnetaan parametrina saatu objekti samaan tyyppiin kuin vertailtava olio, ja vertaillaan objektien muuttujien arvoja. Alla on toteutettu yhdenvertaisuusvertailu SimpleDate-luokalle.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class SimpleDate\\n  {\\n    private int day;\\n    private int month;\\n    private int year;\\n\\n    public SimpleDate(int day, int month, int year)\\n    {\\n      this.day = day;\\n      this.month = month;\\n      this.year = year;\\n    }\\n\\n    public override bool Equals(object compared)\\n    {\\n      // jos oliot ovat samassa muistipaikassa, ne ovat samat\\n      if (this == compared)\\n      {\\n        return true;\\n      }\\n\\n      // jos vertailtava olio on null, \\n      // tai jos oliot eiv\\xE4t ole samaa tyyppi\\xE4, oliot eiv\\xE4t ole samat\\n      if ((compared == null) || !this.GetType().Equals(compared.GetType()))\\n      {\\n        return false;\\n      }\\n\\n      // muunnetaan Object-tyyppinen vertailtava olio SimpleDate-olioksi\\n      // nimelt\\xE4 comparedSimpleDate\\n      SimpleDate comparedSimpleDate = (SimpleDate)compared;\\n\\n      // jos olioiden muuttujien arvot ovat samat, ovat oliot samat\\n      if (this.day == comparedSimpleDate.day &&\\n          this.month == comparedSimpleDate.month &&\\n          this.year == comparedSimpleDate.year)\\n      {\\n        return true;\\n      }\\n\\n      // muulloin oliot eiv\\xE4t ole samat\\n      return false;\\n    }\\n\\n\\n    public override string ToString()\\n    {\\n      return this.day + \\\".\\\" + this.month + \\\".\\\" + this.year;\\n    }\\n  }\\n}\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"T\\xE4h\\xE4n asti olemme vertailleet vain == -operaattorilla, mutta nyt k\\xE4yt\\xE4mme my\\xF6s Equalsia. Ne vertailevat eri asioita. Kokeile, mit\\xE4 tapahtuu, jos vertailet kahta identtist\\xE4 SimpleDatea molemmilla:\", mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  SimpleDate date1 = new SimpleDate(1,2,2020);\\n  SimpleDate date2 = new SimpleDate(1,2,2020);\\n  Console.WriteLine(date1.Equals(date2));\\n  Console.WriteLine(date1 == date2);\\n}\\n\"))), mdx(\"h2\", {\n    \"id\": \"hieman-perintää-inheritance\"\n  }, \"Hieman perint\\xE4\\xE4 (inheritance)\"), mdx(\"p\", null, \"Jokainen luokka jonko luomme (ja jokainen valmis C#:n luokka) perii luokan Object, vaikka se ei olekaan erityisesti n\\xE4kyviss\\xE4 ohjelmakoodissa. T\\xE4m\\xE4n vuoksi mink\\xE4 tahansa luokan ilmentym\\xE4 voidaan antaa parametrina metodille, joka saa parametrinaan Object-tyyppisen muuttujan. Periminen n\\xE4kyy muuallakin: esimerkiksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ToString\"), \"-metodi l\\xF6ytyy vaikka et olisi sit\\xE4 itse toteuttanut, samoin kuin Equals-metodi.\"), mdx(\"p\", null, \"Voimme havainnollistaa t\\xE4t\\xE4 seuraavalla esimerkill\\xE4. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" l\\xF6ytyy Object-luokasta, joka on peritty kaikille luokille.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Bird\\n  {\\n    private string name;\\n\\n    public Bird(string name)\\n    {\\n      this.name = name;\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Bird red = new Bird(\\\"Red\\\");\\n  // K\\xE4yt\\xE4mme metodia GetHashCode n\\xE4ytt\\xE4\\xE4ksemme, ett\\xE4 ne ovat uniikkeja\\n  // Metodi palauttaa olion hash-koodin, joka on kokonaisluku\\n  // Palaamme t\\xE4h\\xE4n my\\xF6hemmin.\\n  Console.WriteLine(red.GetHashCode());\\n\\n  Bird chuck = new Bird(\\\"Chuck\\\");\\n  Console.WriteLine(chuck.GetHashCode());\\n\\n  if (red.Equals(chuck))\\n  {\\n    Console.WriteLine(red + \\\" equals \\\" + chuck);\\n  }\\n  else\\n  {\\n    Console.WriteLine(\\\"They're not equal!\\\");\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"58225482\\n54267293\\nThey're not equal!\\n\")), mdx(\"h2\", {\n    \"id\": \"olion-samankaltaisuus-ja-listat\"\n  }, \"Olion samankaltaisuus ja listat\"), mdx(\"p\", null, \"Tarkastellaan kuinka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \"-metodia k\\xE4ytet\\xE4\\xE4n listojen kanssa. Oletetaan, ett\\xE4 meill\\xE4 on edell\\xE4 kuvattu luokka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bird\"), \" vain oletus \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \"-metodilla (ei m\\xE4\\xE4ritelty meid\\xE4n toimesta).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Bird\\n{\\n  private string name;\\n\\n  public Bird(string name)\\n  {\\n    this.name = name;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Luodaan lista ja lis\\xE4t\\xE4\\xE4n siihen lintu. T\\xE4m\\xE4n j\\xE4lkeen tarkistetaan, onko lintu listalla.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  List<Bird> birds = new List<Bird>();\\n  Bird red = new Bird(\\\"Red\\\");\\n\\n  if (birds.Contains(red))\\n  {\\n    Console.WriteLine(\\\"Red is on the list.\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(\\\"Red is not on the list.\\\");\\n  }\\n\\n  birds.Add(red);\\n  if (birds.Contains(red))\\n  {\\n    Console.WriteLine(\\\"Red is on the list.\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(\\\"Red is not on the list.\\\");\\n  }\\n\\n\\n  Console.WriteLine(\\\"However!\\\");\\n\\n  red = new Bird(\\\"Red\\\");\\n  if (birds.Contains(red))\\n  {\\n    Console.WriteLine(\\\"Red is on the list.\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(\\\"Red is not on the list.\\\");\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Red is not on the list.\\nRed is on the list.\\nHowever!\\nRed is not on the list.\\n\")), mdx(\"p\", null, \"Huomaamme yll\\xE4 olevasta esimerkist\\xE4, ett\\xE4 voimme etsi\\xE4 listalta omia olioitamme. Ensin, kun lintua ei ollut lis\\xE4tty listaan, sit\\xE4 ei l\\xF6ydetty -- ja lis\\xE4\\xE4misen j\\xE4lkeen se l\\xF6ytyi. Kun ohjelma vaihtoi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"red\"), \"-olion uuteen olioon, jolla on t\\xE4sm\\xE4lleen samat sis\\xE4ll\\xF6t kuin aiemmin, se ei kuitenkaan ole sama olio, ja siksi sit\\xE4 ei l\\xF6ydy listalta.\"), mdx(\"p\", null, \"Metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Contains\"), \" k\\xE4ytt\\xE4\\xE4 itseasiassa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \"-metodia vertailuun. Yll\\xE4 olevassa esimerkiss\\xE4, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bird\"), \"-luokassa ei ole m\\xE4\\xE4ritelty omaa vertailumetodia, joten lint jolla on t\\xE4sm\\xE4lleen sama sis\\xE4lt\\xF6 -- mutta eri muistiviite -- ei l\\xF6ydyk\\xE4\\xE4n listalta.\"), mdx(\"p\", null, \"Toteutetaan linnulle sen oma \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Equals\"), \". Metodi tarkastelee onko linnuilla sama nimi -- jos nimet t\\xE4sm\\xE4\\xE4, lintuja voidaan pit\\xE4\\xE4 samoina.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public override bool Equals(object compared)\\n{\\n  // Jos oliot ovat samassa muistipaikassa, ne ovat yhtenev\\xE4t eli sama\\n  if (this == compared)\\n  {\\n    return true;\\n  }\\n\\n  // Jos vertailtava olio on null, tai jos oliot eiv\\xE4t ole samaa tyyppi\\xE4, oliot eiv\\xE4t ole samat\\n  if ((compared == null) || !this.GetType().Equals(compared.GetType()))\\n  {\\n    return false;\\n  }\\n  else\\n  {\\n    // Muutetaan Object-tyyppinen vertailtava olio Bird-olioksi nimelt\\xE4 comparedBird\\n    Bird comparedBird = (Bird)compared;\\n    // Jos vertailtava muuttuja on sama, ovat oliot samat\\n    // Jos ne ovat eri, alla oleva vertailu palauttaa false\\n    return this.name.Equals(comparedBird.name);\\n  }\\n}\\n\")), mdx(\"p\", null, \"Nyt listan Contains tunnistaa linnut, joilla on sama nimi, samaksi linnuksi.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  List<Bird> birds = new List<Bird>();\\n  Bird red = new Bird(\\\"Red\\\");\\n\\n  if (birds.Contains(red))\\n  {\\n    Console.WriteLine(\\\"Red is on the list.\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(\\\"Red is not on the list.\\\");\\n  }\\n\\n  birds.Add(red);\\n  if (birds.Contains(red))\\n  {\\n    Console.WriteLine(\\\"Red is on the list.\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(\\\"Red is not on the list.\\\");\\n  }\\n\\n\\n  Console.WriteLine(\\\"However!\\\");\\n\\n  red = new Bird(\\\"Red\\\");\\n  if (birds.Contains(red))\\n  {\\n    Console.WriteLine(\\\"Red is on the list.\\\");\\n  }\\n  else\\n  {\\n    Console.WriteLine(\\\"Red is not on the list.\\\");\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Red is not on the list.\\nRed is on the list.\\nHowever!\\nRed is on the list.\\n\")), mdx(\"h2\", {\n    \"id\": \"olio-metodin-paluuarvona\"\n  }, \"Olio metodin paluuarvona\"), mdx(\"p\", null, \"Olemme n\\xE4hneet metodeita joiden paluuarvo on totuusarvo, numero tai merkkijono. Kuten arvata saattaa, metodi voi palauttaa mink\\xE4 tahansa objektin (olion).\"), mdx(\"p\", null, \"Seuraavassa esimerkiss\\xE4 luomme uuden yksinkertaisen laskurin jolla on metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Clone\"), \". Metodia voidaan k\\xE4ytt\\xE4\\xE4 luomaan klooni laskurista; eli uusi laskuri jolla on sama arvo kuin kloonattavalla laskurilla.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise001\\n{\\n  public class Counter\\n  {\\n    private int value;\\n\\n    // samalla esimerkkki monesta konstruktorista:\\n    // voit kutsua toista konstruktoria konstruktorista k\\xE4sin k\\xE4ytt\\xE4m\\xE4ll\\xE4 this\\n    // huomaa ett\\xE4 this-kutsu on oltava konstruktorin ensimm\\xE4isell\\xE4 rivill\\xE4\\n    public Counter() : this(0)\\n    {\\n    }\\n\\n    public Counter(int initialValue)\\n    {\\n      this.value = initialValue;\\n    }\\n\\n    public void Increase()\\n    {\\n      this.value = this.value + 1;\\n    }\\n\\n    public override string ToString()\\n    {\\n      return \\\"value: \\\" + value;\\n    }\\n\\n    public Counter Clone()\\n    {\\n      // luodaan uusi laskuri-olio, joka saa arvokseen kloonattavan laskurin arvon\\n      Counter clone = new Counter(this.value);\\n\\n      // palauta klooni kutsujalle\\n      return clone;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Esimerkki laskurin toiminnasta:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Counter counter = new Counter();\\ncounter.Increase();\\ncounter.Increase();\\n\\nConsole.WriteLine(counter);         // tulostaa 2\\n\\nCounter clone = counter.Clone();\\n\\nConsole.WriteLine(counter);         // tulostaa 2\\nConsole.WriteLine(clone);          // tulostaa 2\\n\\ncounter.Increase();\\ncounter.Increase();\\ncounter.Increase();\\ncounter.Increase();\\n\\nConsole.WriteLine(counter);         // tulostaa 6\\nConsole.WriteLine(clone);          // tulostaa 2\\n\\nclone.Increase();\\n\\nConsole.WriteLine(counter);         // tulostaa 6\\nConsole.WriteLine(clone);          // tulostaa 3\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"value: 2\\nvalue: 2\\nvalue: 2\\nvalue: 6\\nvalue: 2\\nvalue: 6\\nvalue: 3\\n\")), mdx(\"p\", null, \"Heti kloonaamisen j\\xE4lkeen laskurien arvot ovat samat. Ne ovat kuitenkin kaksi eri oliota, joten toisen arvon kasvattaminen ei vaikuta toiseen.\"), mdx(\"p\", null, \"Samaan tapaan, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Factory\"), \"-oliota voidaan k\\xE4ytt\\xE4\\xE4 luomaan uusia \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Car\"), \"-olioita. Alla on hahmotelma tehtaasta -- tehdas tiet\\xE4\\xE4 my\\xF6s, mink\\xE4 merkkisi\\xE4 autoja luodaan.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Factory \\n{\\n  private string make;\\n\\n  public Factory(string make) \\n  {\\n    this.make = make;\\n  }\\n\\n  public Car ProcuceCar() \\n  {\\n    return new Car(this.make);\\n  }\\n}\\n\")), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '006 NullReferenceException',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Luo ohjelma joka aiheuttaa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NullReferenceException\"), \" virheen. Virheen tulisi tapahtua heti ohjelman k\\xE4ynnist\\xE4misen j\\xE4lkeen -- \\xE4l\\xE4 odota k\\xE4ytt\\xE4j\\xE4n sy\\xF6tett\\xE4, esimerkiksi.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Vinkki: Muuta olio null:ksi, ja koeta k\\xE4ytt\\xE4\\xE4 sit\\xE4.\")), mdx(Exercise, {\n    title: '007 Health station',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on luokka \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \", joka on meille jo tuttu. Lis\\xE4ksi pohjassa on luonnos luokasta \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HealthStation\"), \" (TerveysAsema suomeksi). Terveysasema-olio k\\xE4sittelee ihmisi\\xE4 eri tavoin, esimerkiksi punnitsemalla ja ruokkimalla heit\\xE4. T\\xE4ss\\xE4 teht\\xE4v\\xE4ss\\xE4 rakennetaan terveysasema. Teht\\xE4v\\xE4pohjassa olevaa Person-luokkaa ei saa muuttaa! \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 1 - Henkil\\xF6iden punnitseminen\")), mdx(\"p\", null, \"Metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Weigh\"), \" saa parametrina henkil\\xF6n, ja sen tarkoituksena on palauttaa parametrina annetun henkil\\xF6n paino. Paino l\\xF6ytyy kutsumalla sopivaa ominaisuutta Person-oliosta. Teht\\xE4v\\xE4si on t\\xE4ydent\\xE4\\xE4 metodin koodi!\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 2 - Henkil\\xF6iden ruokkiminen\")), mdx(\"p\", null, \"On mahdollista muokata parametrina saadun olion tilaa. T\\xE4yt\\xE4 metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public void Feed(Person person)\"), \" terveysasemalle. Sen tulee lis\\xE4t\\xE4 parametrina saadun henkil\\xF6n painoa yhdell\\xE4.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 3 - Punnistusten laskeminen\")), mdx(\"p\", null, \"K\\xE4yt\\xE4 muuttujaa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public int weighings { get; private set; }\"), \" punnitusten laskemiseen - Eli kun metodia \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Weigh\"), \" kutsutaan, muttujan arvon pit\\xE4isi kasvaa yhdell\\xE4.\"), mdx(\"p\", null, \"T\\xE4ss\\xE4 on Main-metodin esimerkki, jolla testataan terveysaseman kaikkia osia:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  // Luo uusi asema\\n  HealthStation childrensHospital = new HealthStation();\\n\\n  // Luo kaksi uutta henkil\\xF6\\xE4\\n  Person ethan = new Person(\\\"Ethan\\\", 1, 110, 7);\\n  Person peter = new Person(\\\"Peter\\\", 33, 176, 85);\\n\\n  // Kokeile henkil\\xF6it\\xE4 ja punnistusta\\n  Console.WriteLine(ethan.name + \\\" weight: \\\" + childrensHospital.Weigh(ethan) + \\\" kilos\\\");\\n  Console.WriteLine(peter.name + \\\" weight: \\\" + childrensHospital.Weigh(peter) + \\\" kilos\\\");\\n\\n  // Kokeile ruokintaa\\n  childrensHospital.Feed(ethan);\\n  childrensHospital.Feed(peter);\\n\\n  // Tarkista, ett\\xE4 paino on noussut\\n  Console.WriteLine(ethan.name + \\\" weight: \\\" + childrensHospital.Weigh(ethan) + \\\" kilos\\\");\\n  Console.WriteLine(peter.name + \\\" weight: \\\" + childrensHospital.Weigh(peter) + \\\" kilos\\\");\\n\\n  // Punnitse muutaman kerran lis\\xE4\\xE4\\n  childrensHospital.Weigh(ethan);\\n  childrensHospital.Weigh(ethan);\\n  childrensHospital.Weigh(ethan);\\n  childrensHospital.Weigh(ethan);\\n\\n  // Tarkista, ett\\xE4 punnitusten lukum\\xE4\\xE4r\\xE4 on 8\\n  Console.WriteLine(\\\"weighings performed: \\\" + childrensHospital.weighings);\\n}\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4n pit\\xE4isi lopulta tulostaa\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Ethan weight: 110 kilos\\nPeter weight: 176 kilos\\nEthan weight: 111 kilos\\nPeter weight: 177 kilos\\nweighings performed: 8\\n\"))), mdx(Exercise, {\n    title: '008 Card payments',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Aiemmissa teht\\xE4viss\\xE4 olemme k\\xE4ytt\\xE4neet luokkaa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PaymentCard\"), \". Kortilla on ollut metodeja lounaan sy\\xF6miseen ja kahvin juomiseen, sek\\xE4 rahan lis\\xE4\\xE4miseen kortille.\"), mdx(\"p\", null, \"On kuitenkin hieman ongelmallista toteuttaa luokka t\\xE4ll\\xE4 tavalla. Kortti tiet\\xE4\\xE4 eri maksujen hinnat, ja pystyy v\\xE4hent\\xE4m\\xE4\\xE4n saldosta oikean m\\xE4\\xE4r\\xE4n. Ent\\xE4 jos hinnat muuttuvat? Tai jos uusia tuotteita lis\\xE4t\\xE4\\xE4n? Hinnan muuttuessa kaikki olemassa olevat kortit pit\\xE4isi korvata uusilla, jotka tiet\\xE4v\\xE4t uudet hinnat.\"), mdx(\"p\", null, \"Parannettu toteutus on tehd\\xE4 kortista \\\"tyhm\\xE4\\\"; tiet\\xE4m\\xE4t\\xF6n hinnoista ja myydyist\\xE4 tuotteista, ja pit\\xE4\\xE4 kirjaa vain omasta saldostaan. Kaikki \\xE4ly on parempi sijoittaa toiseen olioon, eli maksup\\xE4\\xE4tteeseen.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 1\")), mdx(\"p\", null, \"Luodaan ensin \\\"tyhm\\xE4\\\" versio luokasta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PaymentCard\"), \". Kortilla on vain kyky kysy\\xE4 saldoa, lis\\xE4t\\xE4 rahaa ja ottaa rahaa. T\\xE4yt\\xE4 metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public bool TakeMoney(double amount)\"), \" luokassa alla (ja teht\\xE4v\\xE4pohjassa), k\\xE4ytt\\xE4en seuraavaa mallina:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise008\\n{\\n  public class PaymentCard\\n  {\\n    public double balance { get; private set; }\\n\\n    public PaymentCard(double balance)\\n    {\\n      this.balance = balance;\\n    }\\n\\n    public void AddMoney(double increase)\\n    {\\n      this.balance = this.balance + increase;\\n    }\\n\\n    public bool TakeMoney(double amount)\\n    {\\n      // toteuta metodi siten ett\\xE4 se ottaa kortilta rahaa \\n      // vain jos saldo on v\\xE4hint\\xE4\\xE4n amount\\n      // palauttaa true jos onnistui ja false muuten\\n\\n      return false;\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  PaymentCard petesCard = new PaymentCard(10);\\n\\n  Console.WriteLine(\\\"money \\\" + petesCard.balance);\\n  bool wasSuccessful = petesCard.TakeMoney(8);\\n  Console.WriteLine(\\\"successfully withdrew: \\\" + wasSuccessful);\\n  Console.WriteLine(\\\"money \\\" + petesCard.balance);\\n\\n  wasSuccessful = petesCard.TakeMoney(4);\\n  Console.WriteLine(\\\"successfully withdrew: \\\" + wasSuccessful);\\n  Console.WriteLine(\\\"money \\\" + petesCard.balance);\\n\\n}\\n\")), mdx(\"p\", null, \"Pit\\xE4isi tulostaa seuraavaa:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"money 10\\nsuccessfully withdrew: True\\nmoney 2\\nsuccessfully withdrew: False\\nmoney 2\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 2\")), mdx(\"p\", null, \"Kun k\\xE4yd\\xE4\\xE4n opiskelijakahvilassa, on mahdollista maksaa joko k\\xE4teisell\\xE4 tai maksukortilla. Kassahenkil\\xF6 k\\xE4ytt\\xE4\\xE4 maksup\\xE4\\xE4tett\\xE4, ja veloittaa joko k\\xE4teiselt\\xE4 tai kortilta. Ensin toteutetaan maksup\\xE4\\xE4te, joka toimii k\\xE4teisen kanssa.\"), mdx(\"p\", null, \"Maksup\\xE4\\xE4teen hahmotelma. Kommentit kertovat mit\\xE4 metodeiden halutaan tekev\\xE4n:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise008\\n{\\n  public class PaymentTerminal\\n  {\\n    private double money;  // k\\xE4teisen m\\xE4\\xE4r\\xE4 kassassa\\n    private int coffeeAmount; // myytyjen kahvien m\\xE4\\xE4r\\xE4\\n    private int lunchAmount;  // myytyjen lounaiden m\\xE4\\xE4r\\xE4\\n\\n    public PaymentTerminal()\\n    {\\n      // alussa rahaa on 1000 euroa\\n    }\\n\\n    public double DrinkCoffee(double payment)\\n    {\\n      // kahvi maksaa nyt 2.50 euroa\\n      // kasvata kassassa olevaa raham\\xE4\\xE4r\\xE4\\xE4 kahvin hinnalla\\n      // kasvata myytyjen lukum\\xE4\\xE4r\\xE4\\xE4 ja palauta (return) vaihtorahat\\n      // jos maksu ei ole riitt\\xE4v\\xE4, \\xE4l\\xE4 kasvata lukum\\xE4\\xE4r\\xE4\\xE4, palauta koko maksu ja \\xE4l\\xE4 muuta kassassa olevaa raham\\xE4\\xE4r\\xE4\\xE4\\n    }\\n\\n    public double EatLunch(double payment)\\n    {\\n      // lounas maksaa nyt 10.30 euroa\\n      // kasvata kassassa olevaa raham\\xE4\\xE4r\\xE4\\xE4 lounaan hinnalla\\n      // kasvata myytyjen lukum\\xE4\\xE4r\\xE4\\xE4 ja palauta (return) vaihtorahat\\n      // jos maksu ei ole riitt\\xE4v\\xE4, \\xE4l\\xE4 kasvata lukum\\xE4\\xE4r\\xE4\\xE4, palauta koko maksu ja \\xE4l\\xE4 muuta kassassa olevaa raham\\xE4\\xE4r\\xE4\\xE4\\n    }\\n\\n    public override string ToString()\\n    {\\n      return \\\"money: \\\" + money + \\\", number of sold coffees: \\\" + coffeeAmount + \\\", number of sold lunches: \\\" + lunchAmount;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Maksup\\xE4\\xE4te aloittaa 1000 eurolla. Toteuta metodit jotta ne toimivat oikein, perustuen ohjeisiin yll\\xE4 ja alla olevaan esimerkkiin, joka tulostaa maksup\\xE4\\xE4tteen tietoja:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"PaymentTerminal lunchCafeteria = new PaymentTerminal();\\n\\ndouble change = lunchCafeteria.DrinkCoffee(10);\\nConsole.WriteLine(\\\"remaining change \\\" + change);\\n\\nchange = lunchCafeteria.DrinkCoffee(5);\\nConsole.WriteLine(\\\"remaining change \\\" + change);\\n\\nchange = lunchCafeteria.EatLunch(20);\\nConsole.WriteLine(\\\"remaining change \\\" + change);\\n\\nConsole.WriteLine(lunchCafeteria);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"remaining change 7.5\\nremaining change 2.5\\nremaining change 9.7\\nmoney: 1015.3, number of sold coffees: 2, number of sold lunches: 1\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 3\")), mdx(\"p\", null, \"Laajennetaan maksup\\xE4\\xE4tett\\xE4 tukemaan korttimaksuja. Meid\\xE4n tarvitsee luoda uusia metodeja maksup\\xE4\\xE4tteeseen. P\\xE4\\xE4te ottaa korttimaksun vastaan, ja v\\xE4hent\\xE4\\xE4 kortin saldosta ostoksen hinnan. T\\xE4ss\\xE4 j\\xE4lleen hahmotelma, ja ohjeet metodien t\\xE4ydent\\xE4miseen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public bool DrinkCoffee(PaymentCard card)\\n{\\n  // kahvi maksaa 2.50 euroa\\n  // jos kortilla on tarpeeksi rahaa, v\\xE4henn\\xE4 hinta kortilta, kasvata myytyjen lukum\\xE4\\xE4r\\xE4\\xE4 ja palauta true\\n  // muutoin palauta false\\n}\\n\\npublic bool EatLunch(PaymentCard card)\\n{\\n  // lounas maksaa 10.30 euroa\\n  // jos kortilla on tarpeeksi rahaa, v\\xE4henn\\xE4 hinta kortilta, kasvata myytyjen lukum\\xE4\\xE4r\\xE4\\xE4 ja palauta true\\n  // muutoin palauta false\\n}\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"HUOM! Korttimaksu ei lis\\xE4\\xE4 rahaa kassaan, vaan v\\xE4hent\\xE4\\xE4 rahaa kortilta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"PaymentTerminal lunchCafeteria = new PaymentTerminal();\\n\\ndouble change = lunchCafeteria.DrinkCoffee(10);\\nConsole.WriteLine(\\\"remaining change: \\\" + change);\\n\\nPaymentCard annesCard = new PaymentCard(15);\\n\\nbool wasSuccessful = lunchCafeteria.EatLunch(annesCard);\\nConsole.WriteLine(\\\"there was enough money: \\\" + wasSuccessful);\\nwasSuccessful = lunchCafeteria.EatLunch(annesCard);\\nConsole.WriteLine(\\\"there was enough money: \\\" + wasSuccessful);\\nwasSuccessful = lunchCafeteria.DrinkCoffee(annesCard);\\nConsole.WriteLine(\\\"there was enough money: \\\" + wasSuccessful);\\n\\nConsole.WriteLine(lunchCafeteria);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"remaining change: 7.5\\nthere was enough money: True\\nthere was enough money: False\\nthere was enough money: True\\nmoney: 1002.5, number of sold coffees: 2, number of sold lunches: 1\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Osa 4\")), mdx(\"p\", null, \"Luodaan maksup\\xE4\\xE4tteelle metodi jolla voidaan lis\\xE4t\\xE4 rahaa kortille. Muista, ett\\xE4 kortille ladattu raha tallennetaan maksup\\xE4\\xE4tteelle (lis\\xE4t\\xE4\\xE4n k\\xE4teist\\xE4). Pohja metodille:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public void AddMoneyToCard(PaymentCard card, double sum)\\n{\\n  // ...\\n}\\n\")), mdx(\"p\", null, \"Main-metodi havainnollistamaan toimintaa:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  // T\\xE4t\\xE4 kannattaa kokeilla omassa koodissas\\n\\n  PaymentTerminal lunchCafeteria = new PaymentTerminal();\\n  Console.WriteLine(lunchCafeteria);\\n\\n  PaymentCard annesCard = new PaymentCard(2);\\n\\n  Console.WriteLine(\\\"amount of money on the card is \\\" + annesCard.balance + \\\" euros\\\");\\n\\n  bool wasSuccessful = lunchCafeteria.EatLunch(annesCard);\\n  Console.WriteLine(\\\"there was enough money: \\\" + wasSuccessful);\\n\\n  lunchCafeteria.AddMoneyToCard(annesCard, 100);\\n\\n  wasSuccessful = lunchCafeteria.EatLunch(annesCard);\\n  Console.WriteLine(\\\"there was enough money: \\\" + wasSuccessful);\\n\\n  Console.WriteLine(\\\"amount of money on the card is \\\" + annesCard.balance + \\\" euros\\\");\\n\\n  Console.WriteLine(lunchCafeteria);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"money: 1000, number of sold coffees: 0, number of sold lunches: 0\\namount of money on the card is 2 euros\\nthere was enough money: False\\nthere was enough money: True\\namount of money on the card is 91.7 euros\\nmoney: 1100, number of sold coffees: 0, number of sold lunches: 1\\n\"))), mdx(Exercise, {\n    title: '009 Biggest pet shop',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Kaksi luokkaa, Person ja Pet, ovat valmiina teht\\xE4v\\xE4pohjassa. Jokaisella henkil\\xF6ll\\xE4 on yksi lemmikki. Muokkaa metodia \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public override string ToString()\"), \" luokassa Person siten, ett\\xE4 se palauttaa henkil\\xF6n nimen ja lemmikin nimen ja rodun.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n\\n  Pet lucy = new Pet(\\\"Lucy\\\", \\\"golden retriever\\\");\\n  Person leo = new Person(\\\"Leo\\\", lucy);\\n  Console.WriteLine(leo);\\n\\n  Person mike = new Person(\\\"Mike\\\");\\n  Console.WriteLine(mike);\\n  \\n  Person lilo = new Person();\\n  Console.WriteLine(lilo);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Leo, has a friend called Lucy (golden retriever)\\nLilo, has a friend called Stitch (blue alien)\\nMike, has a friend called Toothless (dragon)\\n\"))), mdx(Exercise, {\n    title: '010 Comparing apartments',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"T\\xE4yt\\xE4 metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public bool LargerThan(Apartment compared)\"), \" luokassa Apartment. Metodin tulee palauttaa true jos huoneisto jossa metodia kutsutaan on suurempi kuin parametrina annettu huoneisto. \"), mdx(\"p\", null, \"Esimerkki metodin toiminnasta:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  Apartment manhattanStudioApt = new Apartment(1, 16, 5500);\\n  Apartment atlantaTwoBedroomApt = new Apartment(2, 38, 4200);\\n  Apartment bangorThreeBedroomApt = new Apartment(3, 78, 2500);\\n\\n  Console.WriteLine(manhattanStudioApt.LargerThan(atlantaTwoBedroomApt));\\n  Console.WriteLine(bangorThreeBedroomApt.LargerThan(manhattanStudioApt));\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"False\\nTrue\\n\")), mdx(\"p\", null, \"T\\xE4yt\\xE4 metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public int PriceDifference(Apartment compared)\"), \" luokassa Apartment, joka palauttaa huoneiston hinnan erotuksen. Hinta lasketaan kertomalla neli\\xF6iden m\\xE4\\xE4r\\xE4 neli\\xF6hinnalla. Metodin tulee palauttaa positiivinen luku. K\\xE4yt\\xE4 metodia \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"private int Price()\"), \" huoneiston hinnan laskemiseen.\"), mdx(\"p\", null, \"Esimerkki metodin toiminnasta:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Apartment manhattanStudioApt = new Apartment(1, 16, 5500);\\nApartment atlantaTwoBedroomApt = new Apartment(2, 38, 4200);\\nApartment bangorThreeBedroomApt = new Apartment(3, 78, 2500);\\nConsole.WriteLine(manhattanStudioApt.PriceDifference(atlantaTwoBedroomApt));\\nConsole.WriteLine(bangorThreeBedroomApt.PriceDifference(manhattanStudioApt));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"71600\\n107000\\n\")), mdx(\"p\", null, \"T\\xE4yt\\xE4 metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public bool MoreExpensiveThan(Apartment compared)\"), \" luokassa Apartment, joka palauttaa true jos huoneisto jossa metodia kutsutaan on kalliimpi kuin parametrina annettu huoneisto.\"), mdx(\"p\", null, \"Esimerkki metodin toiminnasta:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Apartment manhattanStudioApt = new Apartment(1, 16, 5500);\\nApartment atlantaTwoBedroomApt = new Apartment(2, 38, 4200);\\nApartment bangorThreeBedroomApt = new Apartment(3, 78, 2500);\\nConsole.WriteLine(manhattanStudioApt.MoreExpensiveThan(atlantaTwoBedroomApt));\\nConsole.WriteLine(bangorThreeBedroomApt.MoreExpensiveThan(manhattanStudioApt));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"False\\nTrue\\n\"))), mdx(Exercise, {\n    title: '011 Song',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on luokka \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Song\"), \" josta voidaan luoda olioita jotka kuvaavat kappaleita. Lis\\xE4\\xE4 luokkaan metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Equals\"), \" joka vertailee kappaleiden yhdenvertaisuutta. Kaksi kappaletta ovat samat jos niiden artisti, nimi ja kesto ovat samat.\"), mdx(\"p\", null, \"Voit kokeilla koodiasi t\\xE4ll\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  Song jackSparrow = new Song(\\\"The Lonely Island\\\", \\\"Jack Sparrow\\\", 196);\\n  Song anotherSparrow = new Song(\\\"The Lonely Island\\\", \\\"Jack Sparrow\\\", 196);\\n\\n  if (jackSparrow.Equals(anotherSparrow))\\n  {\\n    Console.WriteLine(\\\"Songs are equal.\\\");\\n  }\\n\\n  if (jackSparrow.Equals(\\\"Another object\\\"))\\n  {\\n    Console.WriteLine(\\\"Strange things are afoot.\\\");\\n  }\\n}\\n\"))), mdx(Exercise, {\n    title: '012 Books',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on ohjelma joka kysyy k\\xE4ytt\\xE4j\\xE4lt\\xE4 kirjoja ja lis\\xE4\\xE4 ne listaan. \"), mdx(\"p\", null, \"Muokkaa ohjelmaa siten, ett\\xE4 kirjoja lis\\xE4tt\\xE4ess\\xE4 kirjaa ei lis\\xE4t\\xE4 uudelleen, jos se on jo listalla. Kaksi kirjaa ovat samoja, jos niill\\xE4 on sama nimi ja julkaisuvuosi.\"), mdx(\"p\", null, \"Esimerkkitulostus:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Name (empty will stop): \\n> Bossypants \\nPublication year: \\n>2013 \\nName (empty will stop):\\n> Seriously...I'm Kidding\\nPublication year:\\n> 2012 \\nName (empty will stop):\\n> Seriously...I'm Kidding \\nPublication year:\\n> 2012 \\nThe book is already on the list. Let's not add the same book again. \\nName (empty will stop):\\n>\\n\\nThank you! Books added: 2\\n\"))), mdx(Exercise, {\n    title: '013 Archive',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Ohjelman pit\\xE4isi lukea k\\xE4ytt\\xE4j\\xE4lt\\xE4 esineit\\xE4. Kun kaikki esineet on luettu, ohjelma tulostaa kaikkien esineiden tiedot.\"), mdx(\"p\", null, \"Jokaiselle esineelle luetaan tunniste ja nimi. Jos tunniste tai nimi on tyhj\\xE4, lukeminen lopetetaan ja kaikki esineet tulostetaan.\"), mdx(\"p\", null, \"Esimerkkitoiminta:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Identifier? (empty will stop):\\n> B07H8ND8HH \\nName? (empty will stop):\\n> He-Man figure\\nIdentifier? (empty will stop):\\n> B07H8ND8HH \\nName? (empty will stop):\\n> He-Man \\nIdentifier? (empty will stop):\\n> B07NQFMZYG \\nName? (empty will stop):\\n> He-Man figure \\nIdentifier? (empty will stop):\\n> B07NQFMZYG \\nName? (empty will stop):\\n> He-Man figure\\nIdentifier? (empty will stop):\\n>\\n\\n==Items== \\nB07H8ND8HH: He-Man figure \\nB07NQFMZYG: He-Man figure\\n\")), mdx(\"p\", null, \"Tulostusformaatti esineelle on muotoa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"tunniste: nimi\"), \".\"), mdx(\"p\", null, \"Kun esineet on lis\\xE4tty, jokainen esine tulostetaan korkeintaan kerran. Kaksi esinett\\xE4 tulkitaan samaksi, jos niiden tunnisteet ovat samat (esineill\\xE4 voi olla eri nimi eri maissa, esimerkiksi).\"), mdx(\"p\", null, \"Jos k\\xE4ytt\\xE4j\\xE4 sy\\xF6tt\\xE4\\xE4 saman esineen useammin kuin kerran, tulostetaan vain ensin sy\\xF6tetty esine.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"On todenn\\xE4k\\xF6isesti lis\\xE4t\\xE4 esine listalle korkeintaan kerran -- vertaile esineiden samankaltaisuutta perustuen niiden tunnisteisiin.\")), mdx(Exercise, {\n    title: '014 Dating app',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"T\\xE4m\\xE4 teht\\xE4v\\xE4 on 2 pisteen arvoinen ilman erillisi\\xE4 osia.\"), mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on luokka \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleDate\"), \" joka kuvaa p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4\\xE4. P\\xE4iv\\xE4m\\xE4\\xE4r\\xE4 tallennetaan oliomuuttujiin \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"year\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"month\"), \" ja \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"day\"), \". Luokassa on joitain metodeja jotka pit\\xE4\\xE4 toteuttaa:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Advance()\"), \" siirt\\xE4\\xE4 p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4\\xE4 yhdell\\xE4 p\\xE4iv\\xE4ll\\xE4. T\\xE4ss\\xE4 teht\\xE4v\\xE4ss\\xE4 oletamme, ett\\xE4 jokaisessa kuukaudessa on 30 p\\xE4iv\\xE4\\xE4. Muista, ett\\xE4 kuukauden ja vuoden arvoja pit\\xE4\\xE4 muuttaa tietyiss\\xE4 tilanteissa.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Advance(int howManyDays)\"), \" siirt\\xE4\\xE4 p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4\\xE4 parametrina annetun m\\xE4\\xE4r\\xE4n p\\xE4ivi\\xE4. K\\xE4yt\\xE4 metodia Advance() apuna.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public SimpleDate AfterNumberOfDays(int days)\"), \" luo uuden SimpleDate-olion jonka p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4 on parametrina annetun m\\xE4\\xE4r\\xE4n p\\xE4ivi\\xE4 my\\xF6hemmin. Voit edelleen olettaa, ett\\xE4 jokaisessa kuukaudessa on 30 p\\xE4iv\\xE4\\xE4. Huomaa, ett\\xE4 vanha p\\xE4iv\\xE4m\\xE4\\xE4r\\xE4-olio ei saa muuttua!\")), mdx(\"p\", null, \"Koska viimeinen metodi luo uuden olion, koodin rakenteen pit\\xE4isi olla jotakuinkin t\\xE4llainen:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"SimpleDate newDate = new SimpleDate( ... );\\n\\n// Tee jotain t\\xE4\\xE4ll\\xE4\\n\\nreturn newDate;\\n\")), mdx(\"p\", null, \"Koko luokan pohja n\\xE4ytt\\xE4\\xE4 t\\xE4lt\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise014\\n{\\n  public class SimpleDate\\n  {\\n    private int day;\\n    private int month;\\n    private int year;\\n\\n    public SimpleDate(int day, int month, int year)\\n    {\\n      this.day = day;\\n      this.month = month;\\n      this.year = year;\\n    }\\n\\n    public void Advance() {\\n      // Tee jotain t\\xE4\\xE4ll\\xE4\\n    }\\n\\n    public void Advance(int howManyDays) {\\n      // Tee jotain t\\xE4\\xE4ll\\xE4\\n    }\\n\\n    public SimpleDate AfterNumberOfDays(int days) {\\n      SimpleDate newDate = new SimpleDate( ... );\\n\\n      // Tee jotain t\\xE4\\xE4ll\\xE4\\n\\n      return newDate;\\n    }\\n\\n    \\n    public override string ToString()\\n    {\\n      return this.day + \\\".\\\" + this.month + \\\".\\\" + this.year;\\n    }\\n\\n    // tarkistetaan onko t\\xE4m\\xE4 (this) aiemmin kuin verrattava\\n    // olio joka annetaan parametrina (compared)\\n    public bool Before(SimpleDate compared)\\n    {\\n      // vertaa ensin vuosia\\n      if (this.year < compared.year)\\n      {\\n        return true;\\n      }\\n\\n      // jos vuodet samat, vertaa kuukausia\\n      if (this.year == compared.year && this.month < compared.month)\\n      {\\n        return true;\\n      }\\n\\n      // vuodet ja kuukaudet samoja, vertaa p\\xE4ivi\\xE4\\n      if (this.year == compared.year && this.month == compared.month &&\\n          this.day < compared.day)\\n      {\\n        return true;\\n      }\\n\\n      return false;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Esimerkki k\\xE4ytt\\xE4miseen:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  SimpleDate date = new SimpleDate(13, 2, 2015);\\n  Console.WriteLine(\\\"Friday of the examined week is \\\" + date);\\n\\n  SimpleDate newDate = date.AfterNumberOfDays(7);\\n  int week = 1;\\n  while (week <= 7)\\n  {\\n    Console.WriteLine(\\\"Friday after \\\" + week + \\\" weeks is \\\" + newDate);\\n    newDate = newDate.AfterNumberOfDays(7);\\n\\n    week = week + 1;\\n  }\\n\\n  Console.WriteLine(\\\"The date after 790 days from the examined Friday is ... try it out yourself!\\\");\\n  // Console.WriteLine(\\\"Try \\\" + date.AfterNumberOfDays(790));\\n\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Friday of the examined week is 13.2.2015\\nFriday after 1 weeks is 20.2.2015\\nFriday after 2 weeks is 27.2.2015\\nFriday after 3 weeks is 4.3.2015\\nFriday after 4 weeks is 11.3.2015\\nFriday after 5 weeks is 18.3.2015\\nFriday after 6 weeks is 25.3.2015\\nFriday after 7 weeks is 2.4.2015\\nThe date after 790 days from the examined Friday is ... try it out yourself!\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Sen sijaan ett\\xE4 muokkaisimme vanhaa oliota, palautamme uuden olion metodissa AfterNumberOfDays. Kuvittele ett\\xE4 SimpleDate-luokassa olisi metodi Advance, joka toimisi samalla tavalla kuin meid\\xE4n toteuttamamme metodi AfterNumberOfDays, mutta muuttaisi vanhan olion tilaa. T\\xE4ll\\xF6in seuraava koodinp\\xE4tk\\xE4 aiheuttaisi ongelmia.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"SimpleDate now = new SimpleDate(13, 2, 2015);\\nSimpleDate afterOneWeek = now;\\nafterOneWeek.Advance(7);\\n\\nConsole.WriteLine(\\\"Now: \\\" + now);\\nConsole.WriteLine(\\\"After one week: \\\" + afterOneWeek);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Now: 20.2.2015 \\nAfter one week: 20.2.2015\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 johtuu siit\\xE4, ett\\xE4 tavallinen sijoitusoperaatio kopioi viitteen olioon. T\\xE4ss\\xE4 tapauksessa oliot now ja afterOneWeek viittaavat samaan olioon. \")), mdx(Exercise, {\n    title: '015 Money',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"T\\xE4m\\xE4 teht\\xE4v\\xE4 on 2 pisteen arvoinen ilman erillisi\\xE4 osia.\"), mdx(\"p\", null, \"Maksukorttia tehdess\\xE4mme k\\xE4ytimme double-tyyppist\\xE4 muuttujaa rahan m\\xE4\\xE4r\\xE4n kuvaamiseen, Todellisuudessa t\\xE4m\\xE4 ei ole haluttu tapa tehd\\xE4 t\\xE4t\\xE4, koska kuten olemme huomanneet, double-tyypin laskeminen ei ole t\\xE4ysin tarkkaa. J\\xE4rkev\\xE4mpi tapa rahan k\\xE4sittelyyn on luoda oma luokka t\\xE4h\\xE4n tarkoitukseen.\"), mdx(\"p\", null, \"T\\xE4ss\\xE4 on luonnos luokasta Money (raha):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"namespace Exercise015\\n{\\n  public class Money\\n  {\\n\\n    private int euros;\\n    private int cents;\\n\\n    public Money(int euros, int cents)\\n    {\\n      if (cents > 99)\\n      {\\n        euros = euros + cents / 100;\\n        cents = cents % 100;\\n      }\\n\\n      this.euros = euros;\\n      this.cents = cents;\\n    }\\n\\n    public Money Plus(Money addition)\\n    {\\n      Money newMoney = new Money(/* Tee jotain t\\xE4\\xE4ll\\xE4 */);\\n      // luo uusi Money-olio jolla on oikea arvo\\n\\n      // palauta t\\xE4m\\xE4 uusi Money\\n      return newMoney;\\n    }\\n\\n    public Money Minus(Money decreaser)\\n    {\\n      Money newMoney = new Money(/* Tee jotain t\\xE4\\xE4ll\\xE4 */);\\n      // luo uusi Money-olio jolla on oikea arvo\\n\\n      // palauta t\\xE4m\\xE4 uusi Money\\n      return newMoney;\\n    }\\n\\n    public bool LessThan(Money compared)\\n    {\\n      // Tee jotain t\\xE4\\xE4ll\\xE4\\n      return false;\\n    }\\n\\n    public string toString()\\n    {\\n      string zero = \\\"\\\";\\n      if (cents <= 10)\\n      {\\n        zero = \\\"0\\\";\\n      }\\n\\n      return euros + \\\".\\\" + zero + cents + \\\"e\\\";\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Seuraavaksi luodaan muutama operaatio rahan k\\xE4sittelyyn.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Luodaan ensin metodi \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Money Plus(Money addition)\"), \" joka palauttaa uuden raha-olion, jonka arvo on kahden raha-olion summa (kutsuja + parametri).\")), mdx(\"p\", null, \"Pohja metodin toimintaan on seuraava:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public Money Plus(Money addition)\\n{\\n  Money newMoney = new Money(/* Tee jotain t\\xE4\\xE4ll\\xE4 */);\\n  // luo uusi Money-olio jolla on oikea arvo\\n\\n  // palauta t\\xE4m\\xE4 uusi Money\\n  return newMoney;\\n}\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Jos sentit menev\\xE4t yli 99 (eli 100 tai enemm\\xE4n), eurojen m\\xE4\\xE4r\\xE4 kasvaa my\\xF6s!\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Luodaan metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public bool LessThan(Money compared)\"), \" joka palauttaa true jos raha-olio jolle metodi kutsutaan on pienempi kuin raha-olio joka on parametrina.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Luodaan metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public Money Minus(Money decreaser)\"), \" joka palauttaa uuden raha-olion, jonka arvo on kahden raha-olion erotus (kutsuja - parametri). Jos erotus on negatiivinen, palautetaan raha-olio jonka arvo on 0.\"))), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Jos sentit menev\\xE4t alle 0, eurojen m\\xE4\\xE4r\\xE4 v\\xE4henee my\\xF6s!\"), mdx(\"p\", null, \"Esimerkki kaikista metodeista:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Money money = new Money(100, 00);\\nMoney moreMoney = new Money(500, 50);\\n\\nMoney combined = money.Plus(moreMoney);\\n\\nConsole.WriteLine(money);\\nConsole.WriteLine(moreMoney);\\nConsole.WriteLine(combined);\\n\\nMoney lessMoney = moreMoney.Minus(money);\\n\\nConsole.WriteLine(money);\\nConsole.WriteLine(moreMoney);\\nConsole.WriteLine(lessMoney);\\n\\nlessMoney = lessMoney.Minus(money);\\n\\nConsole.WriteLine(money);\\nConsole.WriteLine(moreMoney);\\nConsole.WriteLine(lessMoney);\\n\\nConsole.WriteLine(lessMoney.LessThan(moreMoney));\\nConsole.WriteLine(lessMoney.LessThan(money));\\n\\nlessMoney = lessMoney.Minus(moreMoney);\\nConsole.WriteLine(lessMoney);\\n\")), mdx(\"p\", null, \"Tulostaa:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"100.00e\\n500.50e\\n600.50e\\n100.00e\\n500.50e\\n400.50e\\n100.00e\\n500.50e\\n300.50e\\nTrue\\nFalse\\n0.00e\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#viittausmuuttujan-asettaminen-kopioi-viitteen","title":"Viittausmuuttujan asettaminen kopioi viitteen"},{"url":"#viittausmuuttujan-arvo-voi-olla-null","title":"Viittausmuuttujan arvo voi olla null"},{"url":"#olio-metodin-parametrina","title":"Olio metodin parametrina"},{"url":"#olio-oliomuuttujana","title":"Olio oliomuuttujana"},{"url":"#samantyyppinen-olio-metodin-parametrina","title":"Samantyyppinen olio metodin parametrina"},{"url":"#yhdenvertaisuus-equality","title":"Yhdenvertaisuus (Equality)"},{"url":"#hieman-perintää-inheritance","title":"Hieman perintää (inheritance)"},{"url":"#olion-samankaltaisuus-ja-listat","title":"Olion samankaltaisuus ja listat"},{"url":"#olio-metodin-paluuarvona","title":"Olio metodin paluuarvona"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Oliot ja viittaukset"}}},"pageContext":{"id":"353097e5-919c-535e-810f-17db8569fb18"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}