{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa5/osa5-1",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Olioiden kertausta\",\n  \"nav_order\": 1,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Mist\\xE4 olio-ohjelmoinnissa onkaan kyse? Kelataan v\\xE4h\\xE4n taaksep\\xE4in.\"), mdx(\"p\", null, \"Tarkastellaan, kuinka kello toimii. Kellolla on kolme viisaria: tuntiviisari, minuuttiviisari ja sekuntiviisari. Sekuntiviisari etenee yhden sekunnin v\\xE4lein, minuuttiviisari 60 sekuntin v\\xE4lein ja tuntiviisari 60 minuutin v\\xE4lein. Kun sekuntiviisarin arvo on 60, sen arvo asetetaan nollaksi ja minuuttiviisarin arvoa kasvatetaan yhdell\\xE4. Kun minuuttiviisarin arvo on 60, sen arvo asetetaan nollaksi ja tuntiviisarin arvoa kasvatetaan yhdell\\xE4. Kun tuntiviisarin arvo on 24, se asetetaan nollaksi.\"), mdx(\"p\", null, \"Aika esitet\\xE4\\xE4n aina muodossa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"tunnit:minuutit:sekunnit\"), \", miss\\xE4 tunnit on kahden numeron muodossa (esim. 01 tai 12), minuutit kahden numeron muodossa ja sekunnit my\\xF6s kahden numeron muodossa.\"), mdx(\"p\", null, \"Alla on toteutus kellosta kokonaislukumuuttujien avulla (tulostus voisi olla eristetty omaan metodiinsa, mutta sit\\xE4 ei ole t\\xE4ss\\xE4 tehty).\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n\\nint hours = 0;\\nint minutes = 0;\\nint seconds = 0;\\n\\nwhile (true)\\n{\\n  // 1. Ajan tulostus\\n  if (hours < 10)\\n  {\\n    Console.Write(\\\"0\\\");\\n  }\\n  Console.Write(hours);\\n\\n  Console.Write(\\\":\\\");\\n\\n  if (minutes < 10)\\n  {\\n    Console.Write(\\\"0\\\");\\n  }\\n  Console.Write(minutes);\\n\\n  Console.Write(\\\":\\\");\\n\\n  if (seconds < 10)\\n  {\\n    Console.Write(\\\"0\\\");\\n  }\\n  Console.Write(seconds);\\n  Console.WriteLine();\\n\\n  // 2. Sekuntiviisarin liike\\n  seconds = seconds + 1;\\n\\n  // 3. Muiden viisareiden liike kun se on tarpeellista\\n  if (seconds > 59)\\n  {\\n    minutes = minutes + 1;\\n    seconds = 0;\\n\\n    if (minutes > 59)\\n    {\\n      hours = hours + 1;\\n      minutes = 0;\\n\\n      if (hours > 23)\\n      {\\n        hours = 0;\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Kuten yll\\xE4 on demonstroitu, kolmen kokonaislukumuuttujan avulla toteutetun kellon toiminta ei ole kovin selke\\xE4\\xE4. Ohjelmakoodia lukiessa ei oikein \\\"n\\xE4e\\\", mit\\xE4 tapahtuu. Tunnettu \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fi.wikipedia.org/wiki/Kent_Beck\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"ohjelmistokehitt\\xE4j\\xE4\")), \" on joskus todennut \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand\\\"\"), \".\"), mdx(\"p\", null, \"Tarkoitus on tehd\\xE4 ohjelmasta ymm\\xE4rrett\\xE4v\\xE4mpi.\"), mdx(\"p\", null, \"Koska kellon viisari on itsess\\xE4\\xE4n selke\\xE4 konsepti, hyv\\xE4 idea ohjelman ymm\\xE4rrett\\xE4vyyden kannalta olisi tehd\\xE4 siit\\xE4 oma luokkansa. Tehd\\xE4\\xE4n \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ClockHand\"), \"-luokka, joka kuvaa kelloviisaria, joka sis\\xE4lt\\xE4\\xE4 tietoa sen arvosta, yl\\xE4rajasta (eli kohdasta, jossa viisarin arvo palaa nollaan) ja tarjoaa metodeja viisarin eteenp\\xE4in siirt\\xE4miseen, arvon katsomiseen ja arvon tulostamiseen merkkijonona.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class ClockHand\\n{\\n  public int value { get; set; }\\n  public int limit { get; set; }\\n\\n  public ClockHand(int limit)\\n  {\\n    this.limit = limit;\\n    this.value = 0;\\n  }\\n\\n  public void Advance()\\n  {\\n    this.value = this.value + 1;\\n\\n    if (this.value >= this.limit)\\n    {\\n      this.value = 0;\\n    }\\n  }\\n\\n  public override string ToString()\\n  {\\n    if (this.value < 10)\\n    {\\n      return \\\"0\\\" + this.value;\\n    }\\n\\n    return \\\"\\\" + this.value;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Kun olemme luoneet luokan ClockHand, kellostamme tulee selke\\xE4mpi. Nyt kellon, eli viisareiden, tulostaminen on suoraviivaista, ja viisareiden eteneminen on piilotettu ClockHand-luokkaan. Koska viisarin paluu alkuun tapahtuu automaattisesti ClockHand-luokan m\\xE4\\xE4rittelem\\xE4n yl\\xE4rajamuuttujan avulla, viisareiden yhteistoiminta on hieman erilaista kuin kokonaislukumuuttujien avulla toteutetussa ohjelmassa. Kokonaislukumuuttujia k\\xE4ytt\\xE4v\\xE4 ohjelma tarkasteli, ylittyik\\xF6 viisaria kuvaavan kokonaisluvun arvo yl\\xE4rajan, jonka j\\xE4lkeen sen arvo asetettiin nollaksi ja seuraavaa viisaria kuvaavan kokonaisluvun arvoa kasvatettiin. Kelloviisareiden ollessa kyseess\\xE4 minuuttiviisari etenee, kun sekuntiviisarin arvo on nolla, ja tuntiviisari etenee, kun minuuttiviisarin arvo on nolla.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  ClockHand hours = new ClockHand(24);\\n  ClockHand minutes = new ClockHand(60);\\n  ClockHand seconds = new ClockHand(60);\\n\\n  while (true)\\n  {\\n    // 1. Tulostetaan aika\\n    Console.WriteLine(hours + \\\":\\\" + minutes + \\\":\\\" + seconds);\\n\\n    // 2. Edistet\\xE4\\xE4n sekuntiviisaria\\n    seconds.Advance();\\n\\n    // 3. Edistet\\xE4\\xE4n muita viisareita kun tarpeellista\\n    if (seconds.value == 0)\\n    {\\n      minutes.Advance();\\n\\n      if (minutes.value == 0)\\n      {\\n        hours.Advance();\\n      }\\n    }\\n  }\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Olio-ohjelmointi on p\\xE4\\xE4asiassa erilaisten k\\xE4sitteiden erist\\xE4mist\\xE4 omiin kokonaisuuksiinsa eli abstraktioiden luomista.\"), \" Edellisess\\xE4 esimerkiss\\xE4 saattaa tuntua turhalta luoda olio, joka sis\\xE4lt\\xE4\\xE4 vain yhden kokonaisluvun, koska saman asian voisi tehd\\xE4 suoraan kokonaislukumuuttujilla. N\\xE4in ei kuitenkaan ole aina.\"), mdx(\"p\", null, \"Konspetin erottaminen omaan luokkaansa on monella tapaa hyv\\xE4 idea. Ensinn\\xE4kin tiettyj\\xE4 yksityiskohtia (kuten k\\xE4sien py\\xF6ritt\\xE4minen) voidaan piilottaa luokan sis\\xE4lle eli \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"abstrahoida\"), \". K\\xE4ytt\\xE4j\\xE4n ei tarvitse kirjoittaa if-lausetta ja sijoitusoperaatiota, vaan kellok\\xE4den k\\xE4ytt\\xE4j\\xE4n tarvitsee kutsua selke\\xE4sti nimetty\\xE4 metodia \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Advance()\"), \". Tuotettua kellok\\xE4tt\\xE4 voidaan k\\xE4ytt\\xE4\\xE4 my\\xF6s rakennuspalikkana muissa ohjelmissa - luokka voisi olla esimerkiksi nimelt\\xE4\\xE4n \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CounterLimitedFromTop\"), \". Eli erillisen k\\xE4sitteen luomalla luokalla voi olla useita k\\xE4ytt\\xF6tarkoituksia. Toinen valtava etu on, ett\\xE4 koska kellok\\xE4den toteutuksen yksityiskohdat eiv\\xE4t ole k\\xE4ytt\\xE4j\\xE4n n\\xE4ht\\xE4vill\\xE4, niit\\xE4 voidaan muuttaa haluttaessa.\"), mdx(\"p\", null, \"Ymm\\xE4rsimme kellon sis\\xE4lt\\xE4v\\xE4n kolme viisaria, eli se koostuu kolmesta k\\xE4sitteest\\xE4. Itse asiassa kello on k\\xE4site sin\\xE4ns\\xE4. Eli voimme luoda siit\\xE4kin luokan. Seuraavaksi luomme luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Clock\"), \", joka piilottaa sis\\xE4\\xE4ns\\xE4 kellon viisarit.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Clock\\n{\\n  private ClockHand hours;\\n  private ClockHand minutes;\\n  private ClockHand seconds;\\n\\n  public Clock()\\n  {\\n    this.hours = new ClockHand(24);\\n    this.minutes = new ClockHand(60);\\n    this.seconds = new ClockHand(60);\\n  }\\n\\n  public void Advance()\\n  {\\n    this.seconds.Advance();\\n\\n    if (this.seconds.value == 0)\\n    {\\n      this.minutes.Advance();\\n\\n      if (this.minutes.value == 0)\\n      {\\n        this.hours.Advance();\\n      }\\n    }\\n  }\\n\\n  public override string ToString()\\n  {\\n    return hours + \\\":\\\" + minutes + \\\":\\\" + seconds;\\n  }\\n}\\n\")), mdx(\"p\", null, \"T\\xE4ten ohjelmistomme toiminta tulee entist\\xE4 selke\\xE4mm\\xE4ksi. Kun vertaamme alla olevaa ohjelmaa alkuper\\xE4iseen joka toimi kokonaisluvuilla, huomaammekin, ett\\xE4 ohjelman luettavuus on aivan eri tasolla.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Clock clock = new Clock();\\n\\n  while (true)\\n  {\\n    Console.WriteLine(clock);\\n    clock.Advance();\\n  }\\n}\\n\")), mdx(\"p\", null, \"Toteuttamamme kello on olio jonka toiminto perustuu \\\"yksinkertaisempiin\\\" olioihin eli kellon viisareihin. T\\xE4m\\xE4 on juuri \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"se hieno idea, joka olio-ohjelmoinnissa on: ohjelma rakentuu pienist\\xE4 ja erillisist\\xE4 olioista, jotka toimivat yhdess\\xE4\"), \".\"), mdx(\"h2\", {\n    \"id\": \"olio\"\n  }, \"Olio\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Olio\"), \" viittaa itsen\\xE4iseen entiteettiin jolla on dataa (instanssimuuttujat) ja k\\xE4ytt\\xE4ytymist\\xE4 (metodit) liitettyn\\xE4 siihen. Oliot voivat erota rakenteeltaan ja toiminnaltaan paljonkin: toiset kuvaavat ongelma-aluetta ja toiset koordinoivat eri olioiden v\\xE4list\\xE4 vuorovaikutusta. Oliot vuorovaikuttavat kesken\\xE4\\xE4n metodikutsujen avulla - metodikutsuja k\\xE4ytet\\xE4\\xE4n sek\\xE4 tiedon pyyt\\xE4miseen oliolta ett\\xE4 ohjeiden antamiseen sille. Yleisesti ottaen jokaisella oliolla on selke\\xE4sti m\\xE4\\xE4ritellyt rajat ja k\\xE4ytt\\xE4ytyminen, ja jokainen olio tiet\\xE4\\xE4 vain ne oliot, joita se tarvitsee teht\\xE4v\\xE4ns\\xE4 suorittamiseen. Toisin sanoen olio piilottaa sis\\xE4iset toimintonsa ja tarjoaa k\\xE4ytt\\xF6liittym\\xE4n k\\xE4ytt\\xE4ytymiseen selke\\xE4sti m\\xE4\\xE4riteltyjen metodien avulla. Lis\\xE4ksi olio on riippumaton niist\\xE4 olioista, joita se ei tarvitse teht\\xE4v\\xE4ns\\xE4 suorittamiseen.\"), mdx(\"p\", null, \"Edellisess\\xE4 osassa k\\xE4sittelimme olioiden kuvausta henkil\\xF6iden avulla, jotka oli m\\xE4\\xE4ritelty \\\"Person\\\" luokassa. Kertauksen vuoksi on hyv\\xE4 muistaa luokan tarkoitus: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"luokka\"), \" sis\\xE4lt\\xE4\\xE4 tarvittavan rakenteen olioiden luomiseen, ja m\\xE4\\xE4rittelee my\\xF6s olioiden muuttujat ja metodit. Olio luodaan luokan konstruktorin perusteella.\"), mdx(\"p\", null, \"Henkil\\xF6-oliollamme oli nimi, ik\\xE4, paino ja pituus, sek\\xE4 muutama metodi. Jos mietimme henkil\\xF6-olion rakennetta enemm\\xE4n, voisimme keksi\\xE4 sille lis\\xE4\\xE4 henkil\\xF6\\xF6n liittyvi\\xE4 muuttujia, kuten henkil\\xF6tunnuksen, puhelinnumeron, osoitteen ja silmien v\\xE4rin.\"), mdx(\"p\", null, \"Todellisuudessa henkil\\xF6\\xF6n liittyy kaikenlaista tietoa ja asioita. Kuitenkin kun rakennamme sovellusta, joka k\\xE4sittelee henkil\\xF6it\\xE4, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"henkil\\xF6\\xF6n liittyv\\xE4 toiminnallisuus ja ominaisuudet ker\\xE4t\\xE4\\xE4n sovelluksen k\\xE4ytt\\xF6tarkoituksen mukaan\"), \". Esimerkiksi el\\xE4m\\xE4nhallinta-sovellus voisi pit\\xE4\\xE4 kirjaa edell\\xE4 mainitusta i\\xE4st\\xE4, painosta ja pituudesta, ja tarjota mahdollisuuden laskea painoindeksi ja maksimisyke. Toisaalta viestint\\xE4\\xE4n keskittyv\\xE4 sovellus tallentaisi henkil\\xF6iden s\\xE4hk\\xF6postiosoitteet ja puhelinnumerot, mutta ei tarvitsisi painoa tai pituutta.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Olion tila\"), \" on sen sis\\xE4isten muuttujien arvo tietyll\\xE4 hetkell\\xE4.\"), mdx(\"p\", null, \"Esimerkiss\\xE4mme henkil\\xF6-olio (Person) jolla on nimi, ik\\xE4, paino ja pituus, ja metodit jotka mahdollistavat painoindeksin (englanniksi body mass index, BMI) sek\\xE4 maksimisykkeen (maximum heart rate) laskemisen, n\\xE4ytt\\xE4\\xE4 seuraavalta. Alla pituus ja paino on ilmaistu liukulukuina - pituuden yksikk\\xF6 on metri.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person\\n{\\n  private string name;\\n  private int age;\\n  private double weight;\\n  private double height;\\n\\n  public Person(string name, int age, double weight, double height)\\n  {\\n    this.age = age;\\n    this.name = name;\\n    this.weight = weight;\\n    this.height = height;\\n  }\\n\\n  public double BodyMassIndex()\\n  {\\n    return this.weight / (this.height * this.height);\\n  }\\n\\n  public double MaximumHeartRate()\\n  {\\n    return 206.3 - (0.711 * this.age);\\n  }\\n\\n  public void GrowOlder()\\n  {\\n    if (this.age < 100)\\n    {\\n      this.age = this.age + 1;\\n    }\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.name + \\\", BMI: \\\" + this.BodyMassIndex()\\n          + \\\", maximum heart rate: \\\" + this.MaximumHeartRate();\\n  }\\n}\\n\")), mdx(\"p\", null, \"Maksimisykkeen ja painoindeksin laskeminen onnistuu helposti Person-luokan avulla.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Console.WriteLine(\\\"What's your name?\\\");\\n  string name = Console.ReadLine();\\n  Console.WriteLine(\\\"What's your age?\\\");\\n  int age = Convert.ToInt32(Console.ReadLine());\\n  Console.WriteLine(\\\"What's your weight?\\\");\\n  double weight = Convert.ToDouble(Console.ReadLine());\\n  Console.WriteLine(\\\"What's your height?\\\");\\n  double height = Convert.ToDouble(Console.ReadLine());\\n\\n  Person person = new Person(name, age, weight, height);\\n  Console.WriteLine(person);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"What's your name?\\nLaura Palmer\\nWhat's your age?\\n21\\nWhat's your weight?\\n50.4\\nWhat's your height?\\n173.4\\nLaura Palmer, BMI: 0.0016762251409825073, maximum heart rate: 191.369\\n\")), mdx(\"h2\", {\n    \"id\": \"luokka\"\n  }, \"Luokka\"), mdx(\"p\", null, \"Luokka m\\xE4\\xE4rittelee olioiden rakenteen. Se sis\\xE4lt\\xE4\\xE4 olioiden sis\\xE4iset muuttujat jotka kuvaavat olion dataa, konstruktorin tai konstruktoreita joilla olioita luodaan, sek\\xE4 metodit jotka kuvaavat niiden toimintaa. Rectangle-luokka (suorakaide) kuvattuna alla on hyv\\xE4 esimerkki luokasta.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// luokka\\npublic class Rectangle\\n{\\n\\n  // instanssimuuttujat\\n  private int width;\\n  private int height;\\n\\n  // konstruktori\\n  public Rectangle(int width, int height)\\n  {\\n    this.width = width;\\n    this.height = height;\\n  }\\n\\n  // metodit\\n  public void Widen()\\n  {\\n    this.width = this.width + 1;\\n  }\\n\\n  public void Narrow()\\n  {\\n    if (this.width > 0)\\n    {\\n      this.width = this.width - 1;\\n    }\\n  }\\n\\n  public int SurfaceArea()\\n  {\\n    return this.width * this.height;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return \\\"(\\\" + this.width + \\\", \\\" + this.height + \\\")\\\";\\n  }\\n}\\n\")), mdx(\"p\", null, \"Jotkin metodit yll\\xE4 eiv\\xE4t palauta arvoja (metodit joissa on m\\xE4\\xE4ritelty avainsana void), kun taas toiset palauttavat (metodit joissa on m\\xE4\\xE4ritelty palautettavan arvon tyyppi). Luokka m\\xE4\\xE4rittelee my\\xF6s toString-metodin, joka palauttaa olion tulostamiseen k\\xE4ytett\\xE4v\\xE4n merkkijonon.\"), mdx(\"p\", null, \"Oliot luodaan luokan konstruktorin avulla k\\xE4ytt\\xE4m\\xE4ll\\xE4 avainsanaa new. Alla luodaan kaksi suorakaide-oliota ja tulostetaan niiden tietoja.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Rectangle first = new Rectangle(40, 80);\\n  Rectangle rectangle = new Rectangle(10, 10);\\n  Console.WriteLine(first);\\n  Console.WriteLine(rectangle);\\n\\n  first.Narrow();\\n  Console.WriteLine(first);\\n  Console.WriteLine(first.SurfaceArea());\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"(40, 80)\\n(10, 10)\\n(39, 80)\\n3120\\n\")), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '001 One minute',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on valmiina materiaalissa esitelty \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ClockHand\"), \"-luokka. Toteuta ajastin, eli \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Timer\"), \"-luokka materiaalissa esitelty\\xE4 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Clock\"), \"-luokkaa hy\\xF6dynt\\xE4en.\"), mdx(\"p\", null, \"Ajastimessa on kaksi viisaria, yksi sadasosasekunteille ja toinen sekunneille. Kun ajastin etenee, sadasosasekuntiviisari etenee yhdell\\xE4. Kun sadasosasekuntiviisarin arvo saavuttaa arvon 100, sen arvo asetetaan nollaksi ja sekuntiviisarin arvo kasvaa yhdell\\xE4. Vastaavasti kun sekuntiviisarin arvo saavuttaa arvon 60, sen arvo asetetaan nollaksi.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Timer()\"), \" luo uuden ajastimen.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public override string ToString()\"), \" palauttaa ajastimen merkkijonoesityksen. T\\xE4m\\xE4n tulisi olla muodossa \\\"sekuntit: sadasosasekuntit\\\", jossa molemmat esitet\\xE4\\xE4n aina kahdella numerolla. Esimerkiksi \\\"19:83\\\" edustaa aikaa 19 sekuntia, 83 sadasosaa.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Advance()\"), \" edist\\xE4\\xE4 ajastinta yhdell\\xE4 sadasosasekunnilla.\")), mdx(\"p\", null, \"Voit kokeilla ajastimen toimintaa p\\xE4\\xE4ohjelmassa halutessasi. Alla oleva esimerkkikoodi tarjoaa sinulle ohjelman, jossa ajastin tulostetaan ja se etenee yhdell\\xE4 sadasosasekunnilla.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  // Luo uusi ajastin\\n  Timer timer = new Timer();\\n  // Silmukka joka etenee niin kauan kunnes se keskeytet\\xE4\\xE4n\\n  // Voit keskeytt\\xE4\\xE4 silmukan yhdistelm\\xE4ll\\xE4 CTRL + C\\n  while (true)\\n  {\\n    Console.WriteLine(timer);\\n    timer.Advance();\\n    // V\\xE4h\\xE4n virheenkorjausta, t\\xE4m\\xE4 k\\xE4sitell\\xE4\\xE4n my\\xF6hemmin\\n    // Tunnetaan nimell\\xE4 try-catch\\n    try\\n    {\\n      // Odota sadasosasekunti\\n      // Sleep(1000) odottaa yhden sekunnin, jos haluat testata hitaammalla tahdilla. \\n      System.Threading.Thread.Sleep(10);\\n    }\\n    // Try-catch:n toinen puoli.\\n    // T\\xE4m\\xE4kin k\\xE4sitell\\xE4\\xE4n my\\xF6hemmin. \\n    catch (Exception e)\\n    {\\n      Console.WriteLine(\\\"Error happened: +\\\" + e);\\n    }\\n  }\\n}\\n\"))), mdx(Exercise, {\n    title: '002 Cube',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Luo luokka kuutiolle, eli \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Cube\"), \"-luokka. Luo konstruktori \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public Cube(int edgeLength)\"), \", joka ottaa kuution sivun pituuden parametrinaan.\"), mdx(\"p\", null, \"Luo metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public int Volume()\"), \", joka laskee ja palauttaa kuution tilavuuden. Kuution tilavuus lasketaan kaavalla \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"edgeLength * edgeLength * edgeLength\"), \". Lis\\xE4ksi luo metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public override string ToString()\"), \", joka palauttaa kuution merkkijonoesityksen. Merkkijonoesityksen tulee olla muodossa \\\"The length of the edge is l and the volume v\\\", jossa \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"l\"), \" on sivun pituus ja \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"v\"), \" on tilavuus - molemmat kokonaislukuina.\")), mdx(Exercise, {\n    title: '003 Fitbyte',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://fi.wikipedia.org/wiki/Karvosen_kaava\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"Karvosen kaava\")), \" antaa laskukaavan tavoitesykkeelle (target heart rate) harjoittelun aikana. Tavoitesyke lasketaan kaavalla \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(maximum heart rate - resting heart rate) * (target heart rate percentage) + resting heart rate\"), \", miss\\xE4 tavoitesyke annetaan prosenttina maksimisykkeest\\xE4 (maksimum heart rate).\"), mdx(\"p\", null, \"Esimerkiksi, jos henkil\\xF6n maksimisyke on 200, leposyke 50 ja tavoitesyke 75% maksimisykkeest\\xE4, tavoitesyke on noin ((200-50) * (0.75) + 50), eli 162.5 ly\\xF6nti\\xE4 minuutissa.\"), mdx(\"p\", null, \"Luo \\\"harjoitusavustaja\\\", tai ennemmin luokka \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FitByte\"), \". Sen konstruktori ottaa parametreina i\\xE4n ja leposykkeen.  Harjoitusavustajan tulee tarjota metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TargetHeartRate\"), \", jolle annetaan parametrina prosentuaalinen osuus maksimisykkeest\\xE4 (doublena), arvo v\\xE4lill\\xE4 0-1. Luokan tulee sis\\xE4lt\\xE4\\xE4:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Konstruktori \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Fitbyte(int age, int restingHeartRate)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Metodi \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public double TargetHeartRate(double percentageOfMaximum)\"), \", joka laskee ja palauttaa tavoitesykkeen.\")), mdx(\"p\", null, \"K\\xE4yt\\xE4 kaavaa 206.3 - (0.711 \", \"*\", \" age) maksimisykkeen laskemiseen.\\nK\\xE4yt\\xE4 kaavaa (maxHeartRate - restingHeartRate) \", \"*\", \" percentageOfMaximum + restingHeartRate tavoitesykkeen laskemiseen.\"), mdx(\"p\", null, \"Esimerkki:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  Fitbyte assistant = new Fitbyte(30, 60);\\n  double percentage = 0.5;\\n\\n  while (percentage < 1.0)\\n  {\\n    double target = assistant.TargetHeartRate(percentage);\\n    Console.WriteLine(\\\"Target \\\" + (percentage * 100) + \\\"% of maximum: \\\" + target);\\n    percentage = percentage + 0.1;\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Target 50% of maximum: 122.48500000000001\\nTarget 60% of maximum: 134.98200000000003\\nTarget 70% of maximum: 147.479\\nTarget 80% of maximum: 159.976\\nTarget 89.99999999999999% of maximum: 172.473\\nTarget 99.99999999999999% of maximum: 184.97000000000003\\n\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#olio","title":"Olio"},{"url":"#luokka","title":"Luokka"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Olioiden kertausta"}}},"pageContext":{"id":"b12f6caf-d28d-5bb8-9435-2bd087a01829"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}