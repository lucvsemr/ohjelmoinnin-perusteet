{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa5/osa5-2",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Metodien ja konstruktorien ylikuormitus\",\n  \"nav_order\": 2,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Note = makeShortcode(\"Note\");\nvar Exercise = makeShortcode(\"Exercise\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Palataan Person-luokkaan viel\\xE4 kerran. Katsotaan hieman erilaista versiota luokasta:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person\\n{\\n  private string name;\\n  private int age;\\n  private double weight;\\n  private double height;\\n\\n\\n  public Person(string name)\\n  {\\n    this.name = name;\\n    this.age = 0;\\n    this.weight = 0;\\n    this.height = 0;\\n  }\\n\\n  public double BodyMassIndex()\\n  {\\n    double heigthPerHundred = this.height / 100.0;\\n    return this.weight / (heigthPerHundred * heigthPerHundred);\\n  }\\n\\n  public bool IsAdult()\\n  {\\n    if (this.age < 18)\\n    {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  public void GrowOlder()\\n  {\\n    this.age++;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.name + \\\", age: \\\" + this.age;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Alussa kaikki henkil\\xF6t ovat 0-vuotiaita, koska konstruktori asettaa instanssimuuttujan age arvoksi 0:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public Person(string name)\\n{\\n  this.name = name;\\n  this.age = 0;\\n  this.weight = 0;\\n  this.height = 0;\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"konstruktorin-ylikuormitus\"\n  }, \"Konstruktorin ylikuormitus\"), mdx(\"p\", null, \"Haluaisimme pysty\\xE4 luomaan henkil\\xF6it\\xE4 niin, ett\\xE4 konstruktorille annetaan parametrina my\\xF6s ik\\xE4. T\\xE4m\\xE4 on mahdollista, koska luokalla voi olla useita konstruktoreita. Tehd\\xE4\\xE4n vaihtoehtoinen konstruktori. Vanhaa konstruktoria ei tarvitse poistaa.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public Person(string name)\\n{\\n  this.name = name;\\n  this.age = 0;\\n  this.weight = 0;\\n  this.height = 0;\\n}\\n\\n    public Person(string name, int age)\\n{\\n  this.name = name;\\n  this.age = age;\\n  this.weight = 0;\\n  this.height = 0;\\n}\\n\")), mdx(\"p\", null, \"Nyt meill\\xE4 on kaksi vaihtoehtoista tapaa luoda henkil\\xF6it\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Person paul = new Person(\\\"Paul\\\", 24);\\n  Person ada = new Person(\\\"Ada\\\");\\n  \\n  Console.WriteLine(paul);\\n  Console.WriteLine(ada);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Paul, age: 24\\nAda, age: 0\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 tekniikka, jossa luokalla on kaksi (tai useampi) konstruktori, on nimelt\\xE4\\xE4n \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"konstruktorin ylikuormitus\"), \". Luokalla voi olla useita konstruktoreita, jotka eroavat parametrien m\\xE4\\xE4r\\xE4n tai tyypin perusteella. On kuitenkin mahdotonta olla kaksi konstruktoria, joilla on t\\xE4sm\\xE4lleen samat parametrit. Emme esimerkiksi voi lis\\xE4t\\xE4 konstruktoria \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"public Person(string name, int weight)\"), \", koska k\\xE4\\xE4nt\\xE4j\\xE4 ei pysty erottamaan t\\xE4t\\xE4 konstruktoria kahden parametrin konstruktorista, jossa int-parametri tarkoittaa ik\\xE4\\xE4.e.\"), mdx(\"h2\", {\n    \"id\": \"konstruktorin-kutsuminen\"\n  }, \"Konstruktorin kutsuminen\"), mdx(\"p\", null, \"Kuten ehk\\xE4 huomasit, koodissamme on paljon \\\"copy-pastea\\\" ylikuormitetuissa konstruktoreissa, mik\\xE4 tarkoittaa ett\\xE4 samat rivit toistuvat uudelleen ja uudelleen. Kun katsot ylikuormitettuja konstruktoreita yll\\xE4, niiss\\xE4 on paljon samaa koodia. T\\xE4m\\xE4 ei ole hyv\\xE4. Jos meill\\xE4 olisi viel\\xE4 enemm\\xE4n konstruktoreita, meid\\xE4n pit\\xE4isi olla riveill\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this.name...\"), \" jokaisessa konstruktorissa.\"), mdx(\"p\", null, \"Ensimm\\xE4inen konstruktori, se jossa annamme vain nimen, on oikeastaan erikoistapaus j\\xE4lkimm\\xE4isest\\xE4 konstruktorista, jossa annetaan sek\\xE4 nimi ett\\xE4 ik\\xE4. Ent\\xE4 jos ensimm\\xE4inen konstruktori voisi kutsua toista konstruktoria?\"), mdx(\"p\", null, \"T\\xE4m\\xE4 ei ole ongelma, koska voit kutsua konstruktoria toisesta konstruktorista k\\xE4ytt\\xE4m\\xE4ll\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \"-avainsanaa, joka on sidottu t\\xE4h\\xE4n tarkkaan objektiin!\"), mdx(\"p\", null, \"Muokataan ensimm\\xE4ist\\xE4 konstruktoria niin, ett\\xE4 se ei tee mit\\xE4\\xE4n itse, vaan kutsuu toista konstruktoria ja pyyt\\xE4\\xE4 sit\\xE4 asettamaan i\\xE4n 0:ksi.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// T\\xE4ss\\xE4 kutsutaan toista konstruktoria, ja ik\\xE4ksi asetetaan 0\\npublic Person(string name) : this(name, 0)\\n{\\n}\\n\\npublic Person(string name, int age)\\n{\\n  this.name = name;\\n  this.age = age;\\n  this.weight = 0;\\n  this.height = 0;\\n}\\n\")), mdx(\"p\", null, \"Konstruktorukutsu \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this(name, 0)\"), \" voi vaikuttaa hieman oudolta. K\\xE4yt\\xE4mme avainsanaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" saadaksemme yhden konstruktorin kutsumaan toista konstruktoria, mik\\xE4 v\\xE4hent\\xE4\\xE4 \\\"copy-pastea\\\". Esimerkiss\\xE4 yll\\xE4 voit kuvitella, ett\\xE4 ylempi konstruktori kutsuu alempaa, arvoilla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"name\"), \" ja \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"0\"), \". Koska alempi konstruktori jo m\\xE4\\xE4rittelee, miten n\\xE4it\\xE4 arvoja k\\xE4sitell\\xE4\\xE4n, ei ole tarvetta erikseen m\\xE4\\xE4ritell\\xE4 muuttujia ylemm\\xE4ss\\xE4 konstruktorissa. T\\xE4m\\xE4ntyyppinen konstruktorikutsu ei muuta koodin k\\xE4ytt\\xE4ytymist\\xE4, ja uusia objekteja voidaan luoda kuten ennenkin:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Person paul = new Person(\\\"Paul\\\", 24);\\n  Person ada = new Person(\\\"Ada\\\");\\n  \\n  Console.WriteLine(paul);\\n  Console.WriteLine(ada);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Paul, age: 24\\nAda, age: 0\\n\")), mdx(\"h2\", {\n    \"id\": \"metodin-ylikuormitus\"\n  }, \"Metodin ylikuormitus\"), mdx(\"p\", null, \"Kuten konstruktoreita, my\\xF6s muita metodeita voidaan ylikuormittaa, joten sinulla voi olla monta versiota samasta metodista. J\\xE4lleen, eri versioiden parametrien on oltava erilaisia. Tehd\\xE4\\xE4n toinen versio \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GrowOlder\"), \"-metodista, joka vanhentaa henkil\\xF6\\xE4 sille annetun m\\xE4\\xE4r\\xE4n vuosia.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public void GrowOlder()\\n{\\n  this.age++;\\n}\\n\\npublic void GrowOlder(int years)\\n{\\n  this.age += years;\\n}\\n\")), mdx(\"p\", null, \"Alla \\\"Paul\\\" syntyy 24-vuotiaana, vanhenee vuoden, ja sen j\\xE4lkeen 10 vuotta:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"static void Main(string[] args)\\n{\\n  Person paul = new Person(\\\"Paul\\\", 24);\\n  Console.WriteLine(paul);\\n  paul.GrowOlder();\\n  Console.WriteLine(paul);\\n  paul.GrowOlder(10);\\n  Console.WriteLine(paul);\\n\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Paul, age: 24\\nPaul, age: 25\\nPaul, age: 35\\n\")), mdx(\"p\", null, \"Luokalla Person on nyt kaksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GrowOlder\"), \" -metodia. Kumpi niist\\xE4 suoritetaan riippuu parametrien m\\xE4\\xE4r\\xE4st\\xE4.\"), mdx(\"p\", null, \"Voimme muokata ohjelmaa niin, ett\\xE4 metodi ilman parametreja toteutetaan k\\xE4ytt\\xE4m\\xE4ll\\xE4 metodia \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GrowOlder(int years)\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public void GrowOlder()\\n{\\n  this.GrowOlder(1);\\n}\\n\\npublic void GrowOlder(int years)\\n{\\n  this.age += years;\\n}\\n\")), mdx(\"p\", null, \"Ylikuormitetun metodin kutsuminen on hieman erilainen kuin ylikuormitetun konstruktorin kutsuminen. Ideana on edelleen t\\xE4sm\\xE4lleen sama. Sen sijaan, ett\\xE4 koodi toistuisi kahdesti, k\\xE4yt\\xE4mme \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \"-avainsanaa ja kerromme, mit\\xE4 kutsumme.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Et voi k\\xE4ytt\\xE4 samaa notaatiota kuin konstruktorin kanssa, eik\\xE4 t\\xE4m\\xE4 toimi konstruktorin kanssa. Voit kokeilla, mit\\xE4 tapahtuu (tai millaisia virheilmoituksia saat).\"), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '004 Constructor overload',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on luokka Product, joka kuvaa tuotetta kaupassa. Tuotteella on nimi, sijainti ja paino.\"), mdx(\"p\", null, \"Lis\\xE4\\xE4 seuraavat kolme konstruktoria Product-luokkaan:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Product(string name)\"), \" luo tuotteen, jonka nimi on annettu parametrina. Tuotteen sijainti on \\\"shelf\\\" ja paino on 1.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Product(string name, string location)\"), \" luo tuotteen, jonka nimi ja sijainti on annettu parametrina. Tuotteen paino on 1.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public Product(string name, int weight)\"), \" luo tuotteen, jonka nimi ja paino on annettu parametrina. Tuotteen sijainti on \\\"warehouse\\\".\")), mdx(\"p\", null, \"Voit kokeilla ohjelmaa seuraavalla koodilla:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Product tapeMeasure = new Product(\\\"Tape measure\\\");\\nProduct plaster = new Product(\\\"Plaster\\\", \\\"home improvement section\\\");\\nProduct tyre = new Product(\\\"Tyre\\\", 5);\\n\\nConsole.WriteLine(tapeMeasure);\\nConsole.WriteLine(plaster);\\nConsole.WriteLine(tyre);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Tape measure (1 kg) can be found from the shelf. \\nPlaster (1 kg) can be found from the home improvement section. \\nTyre (5 kg) can be found from the warehouse.\\n\"))), mdx(Exercise, {\n    title: '005 Overloaded counter',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Luo luokka \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Counter\"), \". Luokka sis\\xE4lt\\xE4\\xE4 numeron, jonka arvoa voidaan kasvattaa ja pienent\\xE4\\xE4. Luokalla on seuraavat konstruktorit:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public Counter(int startValue)\"), \" asettaa arvon laskurille konstruktorin parametrina annetun arvon mukaan.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public Counter()\"), \" asettaa arvon laskurille arvoksi 0.\"))), mdx(\"p\", null, \"Seuraavat metodit ja ominaisuudet:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public int value { get; set; }\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Increase()\"), \" kasvata arvoa yhdell\\xE4\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Decrease()\"), \" v\\xE4henn\\xE4 arvoa yhdell\\xE4\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Increase(int increaseBy)\"), \" kasvattaa arvoa parametrina annetulla arvolla. Jos parametrin arvo on negatiivinen, arvo ei muutu.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void Decrease(int decreaseBy)\"), \" v\\xE4hent\\xE4\\xE4 arvoa parametrina annetulla arvolla. Jos parametrin arvo on negatiivinen, arvo ei muutu.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#konstruktorin-ylikuormitus","title":"Konstruktorin ylikuormitus"},{"url":"#konstruktorin-kutsuminen","title":"Konstruktorin kutsuminen"},{"url":"#metodin-ylikuormitus","title":"Metodin ylikuormitus"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Metodien ja konstruktorien ylikuormitus"}}},"pageContext":{"id":"6cb8ca29-1d51-59a7-9471-beb26286284f"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}