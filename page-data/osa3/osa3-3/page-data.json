{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa3/osa3-3",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Taulukot\",\n  \"nav_order\": 3,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Olemme tutustuneet listoihin, joilla on paljon toiminnallisuutta ohjelmoijan el\\xE4m\\xE4\\xE4 helpottamaan. Ehk\\xE4 t\\xE4rkein ominaisuus on lis\\xE4\\xE4minen: Ohjelmoijan n\\xE4k\\xF6kulmasta listan koko on rajaton. Todellisuudessa listoissa ei ole mit\\xE4\\xE4n taikatemppuja -- ne on ohjelmoitu kuten mik\\xE4 tahansa ohjelma tai ty\\xF6kalu, jonka ohjelmointikieli tarjoaa. Kun luot listan, tietokoneen muistista varataan rajoitettu m\\xE4\\xE4r\\xE4 tilaa. Kun lista loppuu, varataan suurempi tila ja edellisen tilan tiedot kopiodaan uuteen.\"), mdx(\"p\", null, \"Vaikka lista on helppo k\\xE4ytt\\xE4\\xE4, joskus tarvitsemme listan esivanhempaa, taulukkoa (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Array\"), \").\"), mdx(\"p\", null, \"Taulukko sis\\xE4lt\\xE4\\xE4 rajallisen m\\xE4\\xE4r\\xE4n kohtia (indeksej\\xE4) arvoille. Taulukon koko (tai pituus) on n\\xE4iden kohtien m\\xE4\\xE4r\\xE4, eli kuinka monta arvoa taulukkoon voi sijoittaa. Taulukon arvoja kutsutaan elementeiksi (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"elements\"), \").\"), mdx(\"h2\", {\n    \"id\": \"taulukon-luominen\"\n  }, \"Taulukon luominen\"), mdx(\"p\", null, \"On kaksi tapaa luoda taulukko. Ensimm\\xE4isess\\xE4 t\\xE4ytyy m\\xE4\\xE4ritell\\xE4 taulukon koko luomisen yhteydess\\xE4. N\\xE4in luodaan taulukko, joka sis\\xE4lt\\xE4\\xE4 kolme kokonaislukua:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] numbers = new int[3];\\n\")), mdx(\"p\", null, \"Taulukko luodaan k\\xE4ytt\\xE4m\\xE4ll\\xE4 lis\\xE4\\xE4m\\xE4ll\\xE4 hakasulkeet sen sis\\xE4lt\\xE4m\\xE4n elementtien tyypin per\\xE4\\xE4n (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"elementtiTyyppi[]\"), \"). Uusi taulukko luodaan kutsumalla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"new\"), \" jota seuraa elementtien tyyppi, hakasulkeet ja taulukon koko hakasulkeissa.\"), mdx(\"p\", null, \"Taulukko johon mahtuu 5 merkkijonoa luodaan seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string[] strings = new string[5];\\n\")), mdx(\"h2\", {\n    \"id\": \"taulukon-elementtien-sijoittaminen-ja-lukeminen\"\n  }, \"Taulukon elementtien sijoittaminen ja lukeminen\"), mdx(\"p\", null, \"Taulukon elementtiin viitataan sen indeksill\\xE4. Seuraavassa esimerkiss\\xE4 luodaan taulukko, joka sis\\xE4lt\\xE4\\xE4 kolme kokonaislukua ja sijoitetaan indekseihin 0 ja 2 arvot. T\\xE4m\\xE4n j\\xE4lkeen tulostetaan taulukon arvot.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] numbers = new int[3];\\nnumbers[0] = 2;\\nnumbers[2] = 5;\\n// numbers[1] on tyhj\\xE4, tai oikeammin arvoltaan 0\\n\\nConsole.WriteLine(numbers[0]);\\nConsole.WriteLine(numbers[2]);\\n\")), mdx(\"p\", null, \"Muuttujan arvon sijoittaminen tiettyyn kohtaan taulukossa toimii hyvin samankaltaisesti kuin mink\\xE4 tahansa muuttujan arvon sijoittaminen. Taulukossa t\\xE4ytyy kuitenkin m\\xE4\\xE4ritell\\xE4 indeksi, eli mihin kohtaan taulukkoa arvo sijoitetaan. Indeksi m\\xE4\\xE4ritell\\xE4\\xE4n hakasulkeissa. Huomaa, ett\\xE4 t\\xE4m\\xE4 on t\\xE4sm\\xE4lleen sama tapa kuin listoissa.\"), mdx(\"p\", null, \"Indeksi on kokonaisluku, jonka arvo on v\\xE4lill\\xE4 \", \"[0, taulukon koko - 1]\", \". Esimerkiksi taulukko, joka sis\\xE4lt\\xE4\\xE4 5 elementti\\xE4, sis\\xE4lt\\xE4\\xE4 indeksit 0, 1, 2, 3 ja 4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] numbers = new int[5];\\nnumbers[0] = 42;\\nnumbers[1] = 13;\\nnumbers[2] = 12;\\nnumbers[3] = 7;\\nnumbers[4] = 1;\\n\\nConsole.WriteLine(\\\"Which index should we access? \\\");\\nint index = Convert.ToInt32(Console.ReadLine());\\n\\nConsole.WriteLine(numbers[index]);\\n\")), mdx(\"p\", null, \"Taulukossa olevan arvon voi my\\xF6s sijoittaa toisen muuttujan arvoksi.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] numbers = new int[5];\\nnumbers[0] = 42;\\nnumbers[1] = 13;\\nnumbers[2] = 12;\\nnumbers[3] = 7;\\nnumbers[4] = 1;\\n\\nConsole.WriteLine(\\\"Which index should we access? \\\");\\nint index = Convert.ToInt32(Console.ReadLine());\\n\\nint number = numbers[index];\\nConsole.WriteLine(number);\\n\")), mdx(\"h2\", {\n    \"id\": \"taulukon-koko-ja-iterointi\"\n  }, \"Taulukon koko ja iterointi\"), mdx(\"p\", null, \"Saat selville taulukon koon k\\xE4ytt\\xE4m\\xE4ll\\xE4 taulukon ominaisuutta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Length\"), \". P\\xE4\\xE4set t\\xE4h\\xE4n k\\xE4siksi kirjoittamalla taulukon nimen, pisteen ja ominaisuuden, eli esimerkiksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"numbers.Length\"), \". Huomaa, ett\\xE4 t\\xE4m\\xE4 ei ole metodikutsu, lopussa ei ole sulkeita.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] numbers = new int[4];\\n\\nnumbers[0] = 12;\\nnumbers[1] = 42;\\nnumbers[2] = 37;\\nnumbers[3] = 9;\\n\\nConsole.WriteLine(\\\"The array has \\\" + numbers.Length + \\\" elements:\\\");\\nfor (int i = 0; i < numbers.Length; i++)\\n{\\n  Console.WriteLine(numbers[i]);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"The array has 4 elements:\\n12\\n42\\n37\\n9\\n\")), mdx(\"p\", null, \"Yll\\xE4 olevassa esimerkiss\\xE4 iteroimme indeksit 0, 1, 2 ja 3, ja jokaisen indeksin j\\xE4lkeen tulostimme arvon joka oli talletettu indeksiin. Ensimm\\xE4isen\\xE4 koodi tulostaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"numbers\", \"[0]\"), \", sitten \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"numbers\", \"[1]\"), \" ja niin edelleen. Iterointi loppuu, kun silmukan ehto \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"i < numbers.Length\"), \" on ep\\xE4tosi, eli indeksille varatun muuttujan arvo on suurempi tai yht\\xE4 suuri kuin taulukon pituus. Huomaa, ett\\xE4 iterointi ei lopu sill\\xE4 hetkell\\xE4 kun indeksin arvo on liian suuri; ehto evaluoidaan vain silmukan alussa.\"), mdx(\"p\", null, \"Jos indeksi osoittaa taulukon ulkopuolelle, eli elementti\\xE4 ei ole olemassa, saamme \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"IndexOutOfRangeException\"), \" -virheen. T\\xE4m\\xE4 virhe kertoo, ett\\xE4 taulukossa ei ole olemassa haluttua indeksi\\xE4. Et voi hakea tietoa taulukon ulkopuolelta, eli indeksist\\xE4 joka on alle nollan, tai enemm\\xE4n kuin taulukon koko.\"), mdx(\"p\", null, \"Seuraavassa esimerkiss\\xE4 on ohjelma joka ensin kysyy k\\xE4ytt\\xE4j\\xE4lt\\xE4 kuinka monta lukua h\\xE4n haluaa sy\\xF6tt\\xE4\\xE4, sitten kysyy k\\xE4ytt\\xE4j\\xE4lt\\xE4 luvut ja lopuksi tulostaa luvut samassa j\\xE4rjestyksess\\xE4. Luvut tallennetaan taulukkoon.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"Console.WriteLine(\\\"How many numbers? \\\");\\nint howMany = Convert.ToInt32(Console.ReadLine());\\n\\nint[] numbers = new int[howMany];\\n\\nConsole.WriteLine(\\\"Enter the numbers:\\\");\\n\\nint index = 0;\\nwhile (index < numbers.length) {\\n    numbers[index] = Convert.ToInt32(Console.ReadLine());\\n    index = index + 1;\\n}\\n\\n\\nConsole.WriteLine(\\\"Here are the numbers again:\\\");\\n\\nindex = 0;\\nwhile (index < numbers.length) {\\n    Console.WriteLine(numbers[index]);\\n    index = index + 1;\\n}\\n\")), mdx(\"p\", null, \"Ohjelman suoritus n\\xE4ytt\\xE4isi kutakuinkin t\\xE4lt\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"How many numbers? \\n> 4 \\nEnter the numbers: \\n> 4 \\n> 8\\n> 2 \\n> 1 \\nHere are the numbers again: \\n4 \\n8 \\n2 \\n1\\n\")), mdx(\"h2\", {\n    \"id\": \"elementtien-tyypit\"\n  }, \"Elementtien tyypit\"), mdx(\"p\", null, \"Voit luoda taulukon lis\\xE4\\xE4m\\xE4ll\\xE4 hakasulkeet sen sis\\xE4lt\\xE4m\\xE4n elementtien tyypin per\\xE4\\xE4n (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"elementtiTyyppi[]\"), \"). T\\xE4m\\xE4n takia taulukon elementit voivat olla mit\\xE4 tahansa tyyppi\\xE4. T\\xE4ss\\xE4 pari esimerkki\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string[] months = new string[12];\\ndouble[] approximations = new double[100];\\n\\nmonths[0] = \\\"January\\\";\\napproximations[0] = 3.14;\\n\")), mdx(\"p\", null, \"Jokaisen ohjelmoijan tulisi tiet\\xE4\\xE4 hieman tietokoneohjelman muistin rakenteesta. Jokainen muuttuja -- oli se sitten primitiivi tai viittaus -- tallennetaan muistiin. Jokaisella muuttujalla on koko, eli m\\xE4\\xE4ritelty m\\xE4\\xE4r\\xE4 bittej\\xE4 (nollia ja ykk\\xF6si\\xE4) jotka se vie muistissa. Muuttujan arvo on my\\xF6s esitetty bittej\\xE4.\"), mdx(\"p\", null, \"Viittaus taulukkoon on itseasiassa tietoa datan sijainnista. Komennolla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"taulukko\", \"[0]\"), \" viittaamme taulukon ensimm\\xE4iseen elementtiin. T\\xE4m\\xE4 voidaan my\\xF6s lukea muodossa \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"Mene taulukon alkuun ja siirry eteenp\\xE4in 0 kertaa muuttujan kokoisia bittej\\xE4 -- ja palauta pala dataa muuttujan kokoisena.\\\"\")), mdx(\"p\", null, \"Muuttujan int koko C#:ssa on 32 bitti\\xE4. Yksi bitti on varattu etumerkille (plus tai miinus), joten suurin mahdollinen luku int muuttujalle on 2^31 -1. Kun luot int taulukon, joka sis\\xE4lt\\xE4\\xE4 4 elementti\\xE4, varataan muistista 4 \", \"*\", \" 32 bitti\\xE4 muistia. Kun k\\xE4yt\\xE4t \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"taulukko\", \"[2]\"), \", luetaan 32 bitti\\xE4 alkaen taulukon alusta + 2 \", \"*\", \" 32 bitti\\xE4.\"), mdx(\"p\", null, \"Jotkin ohjelmointikielet yritt\\xE4v\\xE4t varmistaa, ett\\xE4 ohjelmoija ei mene \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"v\\xE4\\xE4r\\xE4lle alueelle\\\"\"), \". Jos k\\xE4\\xE4nt\\xE4j\\xE4 ei aiheuttaisi poikkeusta kun sanomme \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"taulukko\", \"[-1]\"), \", voisimme lukea datan joka sijaitsee juuri ennen taulukkoa ohjelman muistissa. T\\xE4ss\\xE4 tapauksessa ei olisi mit\\xE4\\xE4n estett\\xE4 kirjoittaa ohjelma, joka lukee koko ohjelman muistin.\"), mdx(\"h2\", {\n    \"id\": \"taulukko-metodin-parametrina\"\n  }, \"Taulukko metodin parametrina\"), mdx(\"p\", null, \"Voit k\\xE4ytt\\xE4\\xE4 taulukoita parametrina metodissa aivan kuten mit\\xE4 tahansa muuttujaa. Koska taulukko on viittaus tyyppi, taulukon arvo on viittaus taulukon sis\\xE4lt\\xE4m\\xE4\\xE4n informaatioon. Kun k\\xE4yt\\xE4t taulukkoa parametrina metodissa, metodi saa kopion viittauksesta taulukkoon.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void ListElements(int[] integerArray)\\n{\\n  Console.WriteLine(\\\"the elements of the array are: \\\");\\n  int index = 0;\\n  while (index < integerArray.Length)\\n  {\\n    int number = integerArray[index];\\n    Console.Write(number + \\\" \\\");\\n    index = index + 1;\\n  }\\n\\n  Console.WriteLine(\\\"\\\");\\n}\\n\")), mdx(\"p\", null, \"K\\xE4yt\\xE4nn\\xF6ss\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] numbers = new int[3];\\nnumbers[0] = 1;\\nnumbers[1] = 2;\\nnumbers[2] = 3;\\n\\nListElements(numbers);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"the elements of the array are: \\n1 2 3 \\n\")), mdx(\"p\", null, \"Kuten jo aiemmin todettiin, voit vapaasti valita parametrin nimen metodissa, nimi ei tarvitse olla sama kuin muuttujan nimi kun kutsut metodia. Yll\\xE4 olevassa esimerkiss\\xE4 kutsuja on nimennyt taulukon \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"integerArray\"), \", kun taas metodia kutsuttaessa parametrin nimi on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"numbers\"), \".\"), mdx(\"p\", null, \"Array on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"olio\"), \" (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"object\"), \"), eli kun muutat taulukkoa metodissa, muutokset s\\xE4ilyv\\xE4t my\\xF6s metodin suorituksen j\\xE4lkeen.\"), mdx(\"h2\", {\n    \"id\": \"lyhyempi-tapa-luoda-taulukko\"\n  }, \"Lyhyempi tapa luoda taulukko\"), mdx(\"p\", null, \"On olemassa my\\xF6s oikotie taulukon luomiseen. T\\xE4ss\\xE4 luodaan taulukko, joka sis\\xE4lt\\xE4\\xE4 kolme kokonaislukua ja alustetaan se arvoilla 100, 1 ja 42:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] numbers = {100, 1, 42};\\n\")), mdx(\"p\", null, \"Eli osana \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"new\"), \" kutsua, voimme my\\xF6s alustaa taulukon arvot antamalla pilkuilla erotetut arvot. T\\xE4m\\xE4 toimii kaikille tyypeille: alla luodaan taulukko merkkijonoja, sitten taulukko liukulukuja. Lopuksi arvot tulostetaan.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string[] arrayOfStrings = {\\\"Mike L.\\\", \\\"Mike P.\\\", \\\"Mike V.\\\"};\\ndouble[] arrayOfFloatingpoints = {1.20, 3.14, 100.0, 0.6666666667};\\n\\nfor (int i = 0; i < arrayOfStrings.Length; i++) {\\n    Console.WriteLine(arrayOfStrings[i] + \\\" \\\" +  arrayOfFloatingpoints[i]);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Mike L. 1.2\\nMike P. 3.14\\nMike V. 100\\n\")), mdx(\"p\", null, \"Kun alustat taulukon arvojen kanssa, taulukon pituus on tarkalleen ottaen arvojen m\\xE4\\xE4r\\xE4. Arvot sijoitetaan taulukkoon j\\xE4rjestyksess\\xE4, eli ensimm\\xE4inen arvo sijoitetaan indeksiin 0, toinen indeksiin 1 jne.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// indeksi         0   1    2    3   4   5     6     7\\nint[] numbers = {100,  1,  42,  23,  1,  1, 3200, 3201};\\n\\n// tulostaa numeron indeksiss\\xE4 0, eli numeron 100\\nConsole.WriteLine(numbers[0]);\\n// tulostaa numeron indeksiss\\xE4 2, eli numeron 42\\nConsole.WriteLine(numbers[2]);\\n\")), mdx(\"p\", null, \"Kuten listoissa, et voi k\\xE4ytt\\xE4\\xE4 indeksi\\xE4 joka on taulukon ulkopuolella. Voit kokeilla seuraavaa esimerkki\\xE4 omalla koneellasi.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"string[] arrayOfStrings = {\\\"Mike L.\\\", \\\"Mike P.\\\", \\\"Mike V.\\\"};\\ndouble[] arrayOfFloatingpoints = {1.20, 3.14, 100.0, 0.6666666667};\\n\\nfor (int i = 0; i < arrayOfFloatingpoints.Length; i++) {\\n    Console.WriteLine(arrayOfStrings[i] + \\\" \\\" +  arrayOfFloatingpoints[i]);\\n}\\n\")), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '017 Swap indices',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on valmiina ohjelma, joka luo taulukon ja tulostaa sen arvot kahdesti. Muokkaa ohjelmaa niin, ett\\xE4 ensimm\\xE4isen tulostuksen j\\xE4lkeen ohjelma kysyy k\\xE4ytt\\xE4j\\xE4lt\\xE4 kaksi indeksi\\xE4. Ohjelma vaihtaa n\\xE4iden indeksien arvot kesken\\xE4\\xE4n ja tulostaa taulukon arvot uudelleen.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"1 \\n3 \\n5 \\n7 \\n9\\n\\nGive two indices to swap: \\n> 2 \\n> 4\\n\\n1 \\n3 \\n9 \\n7 \\n5\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"1 \\n3 \\n5 \\n7 \\n9\\n\\nGive two indices to swap: \\n> 0 \\n> 1\\n\\n3 \\n1 \\n5 \\n7 \\n9\\n\")), mdx(\"p\", null, \"Voit olettaa, ett\\xE4 k\\xE4ytt\\xE4j\\xE4 antaa oikeanlaisia indeksej\\xE4.\"), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Tarvitset lis\\xE4muuttujan, johon tallennat toisen arvon hetkeksi.\")), mdx(Exercise, {\n    title: '018 Searching array',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on valmiina taulukko jossa on numeroita. T\\xE4ydenn\\xE4 ohjelmaa siten, ett\\xE4 ohjelma kysyy k\\xE4ytt\\xE4j\\xE4lt\\xE4 lukua, jonka j\\xE4lkeen ohjelma kertoo l\\xF6ytyyk\\xF6 luku taulukosta. Jos luku l\\xF6ytyy, ohjelma kertoo my\\xF6s monennellako indeksill\\xE4 luku on taulukossa. Jos lukua ei l\\xF6ydy, ohjelma kertoo, ettei lukua l\\xF6ytynyt.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Search for? \\n> 3 \\n3 is at index 4.\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Search for? \\n> 7 \\n7 is at index 7.\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Search for? \\n> 22 \\n22 was not found.\\n\"))), mdx(Exercise, {\n    title: '019 Sum of numbers in array',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public static int SumOfNumbersInArray(int[] array)\"), \". T\\xE4ydenn\\xE4 metodia siten, ett\\xE4 se laskee ja palauttaa taulukon arvojen summan.\"), mdx(\"p\", null, \"Voit testata toiminnallisuutta t\\xE4ll\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] numbers = {5, 1, 3, 4, 2};\\nint sum = SumOfNumbersInArray(numbers);\\nConsole.WriteLine(sum);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"15\\n\"))), mdx(Exercise, {\n    title: '020 Print neatly',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"T\\xE4ydenn\\xE4 metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public static void PrintNeatly(int[] array)\"), \" siten, ett\\xE4 se tulostaa taulukon arvot siististi. Taulukon arvot tulostetaan yhdelle riville ja jokaisen arvon per\\xE4\\xE4n tulee pilkku ja v\\xE4lily\\xF6nti. Viimeisen arvon per\\xE4\\xE4n ei tule pilkkua, vaan rivinvaihto.\"), mdx(\"p\", null, \"Tulosta numerot yhdelle riville k\\xE4ytt\\xE4m\\xE4ll\\xE4 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Console.Write\"), \".\"), mdx(\"p\", null, \"Voit kokeilla tulostusta t\\xE4ll\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] array = {5, 1, 3, 4, 2};\\nPrintNeatly(array);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"5, 1, 3, 4, 2\\n\"))), mdx(Exercise, {\n    title: '021 Array in stars',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"T\\xE4ydenn\\xE4 metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public static void PrintArrayInStars(int[] array)\"), \" siten, ett\\xE4 se tulostaa taulukon arvot t\\xE4htin\\xE4. Taulukon arvon suuruinen rivi t\\xE4hti\\xE4 tulostetaan jokaiselle arvolle.\"), mdx(\"p\", null, \"Voit kokeilla tulostusta t\\xE4ll\\xE4:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"int[] array = {5, 1, 3, 4, 2};\\nPrintArrayInStars(array);\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"***** \\n* \\n*** \\n**** \\n**\\n\")), mdx(\"p\", null, \"Taulukon nollas elementti on 5, joten ensimm\\xE4isell\\xE4 rivill\\xE4 on 5 t\\xE4hte\\xE4. Seuraavalla rivill\\xE4 on 1 t\\xE4hti, sitten 3 t\\xE4hte\\xE4 jne.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#taulukon-luominen","title":"Taulukon luominen"},{"url":"#taulukon-elementtien-sijoittaminen-ja-lukeminen","title":"Taulukon elementtien sijoittaminen ja lukeminen"},{"url":"#taulukon-koko-ja-iterointi","title":"Taulukon koko ja iterointi"},{"url":"#elementtien-tyypit","title":"Elementtien tyypit"},{"url":"#taulukko-metodin-parametrina","title":"Taulukko metodin parametrina"},{"url":"#lyhyempi-tapa-luoda-taulukko","title":"Lyhyempi tapa luoda taulukko"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Taulukot"}}},"pageContext":{"id":"c2b0e388-bd6a-5bf6-a2e7-0738bea4e92d"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}