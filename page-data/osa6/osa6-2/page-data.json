{
    "componentChunkName": "component---src-templates-docs-js",
    "path": "/osa6/osa6-2",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Staattisuus ja ei-staattisuus\",\n  \"nav_order\": 2,\n  \"hidden\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Exercise = makeShortcode(\"Exercise\");\nvar Note = makeShortcode(\"Note\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"luokkien-ja-olioiden-metodit-staattisuus\"\n  }, \"Luokkien ja olioiden metodit: staattisuus\"), mdx(\"p\", null, \"Alussa useimmat metodimme sis\\xE4lsiv\\xE4t avainsanan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"static\"), \", mutta olioiden my\\xF6t\\xE4 luovuimme siit\\xE4 kokonaan. Miksi?\"), mdx(\"p\", null, \"C#:ssa metodit voidaan jakaa kahteen ryhm\\xE4\\xE4n, jotka m\\xE4\\xE4ritell\\xE4\\xE4n avainsanalla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"static\"), \". Avainsanan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"static\"), \" puuttuessa metodit ovat \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"olion metodeja\"), \", jotka kuuluvat tiettyyn olioon luokan sijaan.\"), mdx(\"p\", null, \"Luokissa voit lis\\xE4t\\xE4 avainsanan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"static\"), \" kenttiin, metodeihin, ominaisuuksiin, operaattoreihin, tapahtumiin ja konstruktoreihin (englanniksi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"fields, methods, properties, operators, events, constructors\"), \").\"), mdx(\"p\", null, \"Oliometodit ovat metodeja, jotka kuuluvat olioihin, ja joiden koodissa voidaan k\\xE4sitell\\xE4 olion omia muuttujia ja muita oliometodeja. Oliometodeissa voidaan k\\xE4ytt\\xE4\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \"-avainsanaa, joka viittaa kyseiseen olioon.\"), mdx(\"p\", null, \"Alla on esimerkki luokasta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Item\"), \", jolla on kolme oliometodia. Jokainen metodi voi k\\xE4sitell\\xE4 oliomuuttujia.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Item\\n{\\n   private string name;\\n\\n   public Item(string name) \\n   {\\n     this.name = name;\\n   }\\n\\n  // C#:ssa t\\xE4m\\xE4 voisi olla my\\xF6s { get; set; } muuttujalle\\n  // T\\xE4ll\\xF6in muuttuja olisi julkinen\\n  // T\\xE4ss\\xE4 esimerkiss\\xE4 haluamme suojata muuttujan ja pit\\xE4\\xE4 sen yksityisen\\xE4 \\n    public string GetName()\\n  {\\n    return this.name;\\n  }\\n\\n  public string SetName(string name) \\n  {\\n    this.name = name;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.name;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Toisin kuin oliometodit, luokkametodit voivat k\\xE4sitell\\xE4 vain muuttujia jotka annetaan parametreina tai jotka luodaan metodin sis\\xE4ll\\xE4. Alla on esimerkki luokasta \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Printer\"), \", jolla on kaksi luokkametodia. Ensimm\\xE4inen tulostaa annetun merkkijonon alaviivoilla, ja toinen tulostaa viivoja annetun m\\xE4\\xE4r\\xE4n.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Printer\\n{\\n  // class methods\\n  public static void PrintUnderscored(string input)\\n  {\\n    Console.WriteLine(input);\\n    PrintLine(input.Length);\\n  }\\n\\n  public static void PrintLine(int length)\\n  {\\n    for (int i = 0; i < length; i++)\\n    {\\n      Console.Write(\\\"-\\\");\\n    }\\n    Console.WriteLine();\\n  }\\n}\\n\")), mdx(\"p\", null, \"Oliometodin kutsumiseen tarvitaan olio, jonka metodia kutsumme (muotoa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"olioNimi.MetodinNimi\"), \"). Luokkametodeita voidaan kutsua ilman oliota (kutsu muodossa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MetodinNimi\"), \"). Jos haluamme kutsua luokkametodia luokan ulkopuolelta, kutsu on muodossa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"LuokanNimi.MetodinNimi\"), \".\"), mdx(\"p\", null, \"Tarkastellaan esimerkkej\\xE4 yll\\xE4 olevista luokista \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Program\"), \"-luokassa. K\\xE4yt\\xE4mme esimerkiss\\xE4 luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Printer\"), \" luokkametodeja, ja luokan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Item\"), \" oliota ja sen metodeja.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Program \\n{\\n  public static void Main(string[] args)\\n  {\\n    Printer.PrintUnderscored(\\\"Hello World!\\\");\\n\\n    Item chair = new Item(\\\"Kartell Louis Ghost\\\");\\n    Printer.PrintLine(chair.GetName().Length);\\n    Printer.PrintUnderscored(chair.ToString());\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Hello World!\\n------------\\n-------------------\\nKartell Louis Ghost\\n-------------------\\n\")), mdx(\"h2\", {\n    \"id\": \"oliot-luokkametodin-parametrina\"\n  }, \"Oliot luokkametodin parametrina\"), mdx(\"p\", null, \"Tarkastellaan ohjelmaa, joka k\\xE4sittelee listoja. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Main\"), \"-metodissa on toiminnallisuus, joka k\\xE4sittelee listan kokonaislukuja. Lis\\xE4ksi luokalla on luokkametodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ZeroList\"), \", joka toimii nimens\\xE4 mukaisesti, asettaen nollan jokaiseen listaan saamaansa arvoon.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Program \\n{\\n  public static void Main(string[] args)\\n  {\\n    List<int> numbers = new List<int>();\\n    numbers.Add(1);\\n    numbers.Add(2);\\n    numbers.Add(3);\\n    numbers.Add(4);\\n    numbers.Add(5);\\n\\n    foreach (int number in numbers)\\n    {\\n      Console.Write(number + \\\" \\\"); // Tulostaa 1 2 3 4 5\\n    }\\n    Console.WriteLine();\\n\\n    ZeroList(numbers);\\n\\n    foreach (int number in numbers)\\n    {\\n      Console.Write(number + \\\" \\\"); // Tulostaa 0 0 0 0 0\\n    }\\n  }\\n\\n  public static void ZeroList(List<int> list)\\n  {\\n    for (int i = 0; i < list.Count; i++)\\n    {\\n      list[i] = 0;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Yll\\xE4 olevassa esimerkiss\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ZeroList\"), \"-metodilla on avainsana \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"static\"), \", ja sit\\xE4 kutsutaan ilman oliota ennen sit\\xE4.\"), mdx(\"p\", null, \"Voimme antaa luokkametodille (tai \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"staattiselle metodille\"), \") olion parametrina (jota olemme itseasiassa tehneet jo jonkin aikaa todelisuudessa). Luokkametodit eiv\\xE4t kuitenkaan voi k\\xE4sitell\\xE4 muita numeroita, merkkijonoja tai olioita kuin niit\\xE4, jotka annetaan parametreina tai jotka luodaan metodin sis\\xE4ll\\xE4.\"), mdx(\"p\", null, \"Toisinsanoen, luokkametodia k\\xE4ytt\\xE4v\\xE4n koodin t\\xE4ytyy tukea metodia antamalla sille arvot ja oliot, joita se k\\xE4ytt\\xE4\\xE4.\"), mdx(\"p\", null, \"Koska luokkametodi ei ole sidoksissa yhteenk\\xE4\\xE4n olioon, sit\\xE4 ei kutsuta samalla tavalla kuin oliometodia (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"olioNimi.MetodinNimi()\"), \"), vaan kutsumme sit\\xE4 (samassa luokassa) vain metodin nimell\\xE4. Jos luokkametodia kutsutaan luokan ulkopuolelta, se voidaan kutsua muodossa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"LuokanNimi.StaattinenMetodi()\"), \".\"), mdx(\"p\", null, \"Alla on sama esimerkki, muutettuna siten, ett\\xE4 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Main\"), \"-metodi ja metodi ovat omissa luokissaan:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Program \\n{\\n  public static void Main(string[] args)\\n  {\\n    List<int> numbers = new List<int>();\\n    numbers.Add(1);\\n    numbers.Add(2);\\n    numbers.Add(3);\\n    numbers.Add(4);\\n    numbers.Add(5);\\n\\n    foreach (int number in numbers)\\n    {\\n      Console.Write(number + \\\" \\\"); // Prints 1 2 3 4 5\\n    }\\n    Console.WriteLine();\\n\\n    Lists.ZeroList(numbers);\\n\\n    foreach (int number in numbers)\\n    {\\n      Console.Write(number + \\\" \\\"); // Prints 0 0 0 0 0\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Lists \\n{\\n  public static void ZeroList(List<int> list)\\n  {\\n    for (int i = 0; i < list.Count; i++)\\n    {\\n      list[i] = 0;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Staattinen metodi joka m\\xE4\\xE4ritell\\xE4\\xE4n toisessa luokassa, t\\xE4ll\\xE4 kertaa luokassa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Lists\"), \", kutsutaan yll\\xE4 olevassa esimerkiss\\xE4 muodossa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Lists.ZeroList(\"), \" parametrit \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \");\"), \".\"), mdx(\"h2\", {\n    \"id\": \"milloin-tulisi-käyttää-luokkametodeja\"\n  }, \"Milloin tulisi k\\xE4ytt\\xE4\\xE4 luokkametodeja\"), mdx(\"p\", null, \"Kaikki metodit jotka k\\xE4sittelev\\xE4t olioiden tilaa, t\\xE4ytyy m\\xE4\\xE4ritell\\xE4 oliometodeina, eli ilman avainsanaa \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"static\"), \". Aiemmissa osissa olemme m\\xE4\\xE4ritelleet luokkia kuten \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person, SimpleDate, Item, ...\"), \", joiden kaikki metodit tulisi m\\xE4\\xE4ritell\\xE4 ilman \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"static\"), \".\"), mdx(\"p\", null, \"Palataan luokkaan \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \". Alla on osa luokasta. Kaikki oliomuuttujat viitataan avainsanalla \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"this\"), \" korostaaksemme, ett\\xE4 metodit k\\xE4ytt\\xE4v\\xE4t oliomuuttujia \\\"sis\\xE4ll\\xE4\\\" oliossa.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Person\\n{\\n  private string name;\\n  private int age;\\n\\n  public Person(string givenName) \\n  {\\n    this.name = givenName;\\n    this.age = 0;\\n  }\\n\\n  public bool IsOfAge()\\n  {\\n    return (this.age >= 18);\\n  }\\n\\n  public void GrowOlder()\\n  {\\n    this.age++;\\n  }\\n\\n  public override string ToString()\\n  {\\n    return this.name;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Kun metodit k\\xE4sittelev\\xE4t oliota, niit\\xE4 ei voida m\\xE4\\xE4ritt\\xE4\\xE4 staattisiksi, eli \\\"riippumattomiksi oliosta\\\". Jos yrit\\xE4mme tehd\\xE4 n\\xE4in, metodi ei toimi. Alla oleva metodi ei toimi:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void GrowOlder()\\n{\\n  this.age++;\\n}\\n\")), mdx(\"p\", null, \"Tuloksena saamme virheen:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Member 'Exercise001.Person.GrowOlder()' cannot be accessed with an instance reference; qualify it with a type name instead\\n(38:5) Keyword 'this' is not valid in a static property, static method, or static field initializer\\n\")), mdx(\"p\", null, \"T\\xE4m\\xE4 tarkoittaa sit\\xE4, ett\\xE4 staattinen metodi ei voi k\\xE4sitell\\xE4 oliomuuttujia.\"), mdx(\"p\", null, \"No milloin sitten tulisi k\\xE4ytt\\xE4\\xE4 staattisia metodeja? Katsotaan seuraavaa esimerkki\\xE4, jossa meill\\xE4 on henkil\\xF6-olioita. Ohjelmassa luomme henkil\\xF6it\\xE4, kasvatamme heit\\xE4 vanhemmiksi ja lopulta tulostamme tietoa siit\\xE4, ovatko he t\\xE4ysi-ik\\xE4isi\\xE4.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Program\\n{\\n  public static void Main(string[] args)\\n  {\\n    Person ada = new Person(\\\"Ada\\\");\\n    Person jack = new Person(\\\"Jack\\\");\\n    Person mike = new Person (\\\"Mike\\\");\\n\\n    for (int i = 0; i < 30; i++)\\n    {\\n      ada.GrowOlder();\\n      mike.GrowOlder();\\n    }\\n\\n    jack.GrowOlder();\\n\\n    if (ada.IsOfAge())\\n    {\\n      Console.WriteLine(ada + \\\" is of age\\\");\\n    }\\n    else\\n    {\\n      Console.WriteLine(ada + \\\" is under age\\\");\\n    }\\n\\n        if (mike.IsOfAge())\\n    {\\n      Console.WriteLine(mike + \\\" is of age\\\");\\n    }\\n    else\\n    {\\n      Console.WriteLine(mike + \\\" is under age\\\");\\n    }\\n\\n        if (jack.IsOfAge())\\n    {\\n      Console.WriteLine(jack + \\\" is of age\\\");\\n    }\\n    else\\n    {\\n      Console.WriteLine(jack + \\\" is under age\\\");\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Kuten n\\xE4emme, koodi joka kertoo henkil\\xF6n t\\xE4ysi-ik\\xE4isyydest\\xE4 on kopioitu kolmeen kertaan. T\\xE4m\\xE4 on rumaa!\"), mdx(\"p\", null, \"T\\xE4ss\\xE4 on hyv\\xE4 tilaisuus k\\xE4ytt\\xE4\\xE4 staattista metodia. Kirjoitetaan ohjelma uudelleen, k\\xE4ytt\\xE4en metodia:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public class Program\\n{\\n  public static void Main(string[] args)\\n  {\\n    Person ada = new Person(\\\"Ada\\\");\\n    Person jack = new Person(\\\"Jack\\\");\\n    Person mike = new Person (\\\"Mike\\\");\\n\\n    for (int i = 0; i < 30; i++)\\n    {\\n      ada.GrowOlder();\\n      mike.GrowOlder();\\n    }\\n\\n    jack.GrowOlder();\\n\\n    TellIfOfAge(ada);\\n    TellIfOfAge(mike);\\n    TellIfOfAge(jack);\\n  }\\n\\n  public static void TellIfOfAge(Person person) \\n  {\\n    if (person.IsOfAge())\\n    {\\n      Console.WriteLine(person + \\\" is of age\\\");\\n    }\\n    else\\n    {\\n      Console.WriteLine(person + \\\" is under age\\\");\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Metodi \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TellIfOfAge\"), \" on m\\xE4\\xE4ritelty staattiseksi, joten se ei ole kiinnitetty mihink\\xE4\\xE4n olioon, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MUTTA\"), \" metodi saa olion parametrina. Metodia ei ole m\\xE4\\xE4ritelty \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \"-luokassa, vaikka se k\\xE4sittelee \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Person\"), \"-olioita. Se on apumetodi p\\xE4\\xE4ohjelmalle, joka tekee p\\xE4\\xE4ohjelmasta luettavamman.\"), mdx(\"h1\", {\n    \"id\": \"tehtävät\"\n  }, \"Teht\\xE4v\\xE4t\"), mdx(Exercise, {\n    title: '003 How many names',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on luokka \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" ja sen k\\xE4ytt\\xF6\\xE4 Mainissa. Tee Main-luokkaan metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public static void HowManyNames(Person person)\"), \", joka tulostaa nimen ja sen nimien m\\xE4\\xE4r\\xE4n seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  Person ada = new Person(\\\"Ada Lovelace\\\");\\n  Person jack = new Person(\\\"Jack The Ripper\\\");\\n  Person mike = new Person(\\\"Mike The Incredible Magic Mouse\\\");\\n\\n  HowManyNames(ada);\\n  HowManyNames(jack);\\n  HowManyNames(mike);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Ada Lovelace has 2 names.\\nJack The Ripper has 3 names.\\nMike The Incredible Magic Mouse has 5 names.\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Console.WriteLine kutsutaan metodin sis\\xE4lt\\xE4 t\\xE4ll\\xE4 kertaa!\")), mdx(Exercise, {\n    title: '004 How many names in person',\n    mdxType: \"Exercise\"\n  }, mdx(\"p\", null, \"Teht\\xE4v\\xE4pohjassa on luokka \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" ja sen k\\xE4ytt\\xF6\\xE4 Mainissa. Tee luokkaan \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" metodi \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public int HowManyNames()\"), \", joka palauttaa nimen ja sen nimien m\\xE4\\xE4r\\xE4n seuraavasti:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public static void Main(string[] args)\\n{\\n  Person ada = new Person(\\\"Ada Lovelace\\\");\\n  Person jack = new Person(\\\"Jack The Ripper\\\");\\n  Person mike = new Person(\\\"Mike The Incredible Magic Mouse\\\");\\n\\n  Console.WriteLine(ada + \\\" has \\\" ada.HowManyNames() + \\\" names.\\\");\\n  Console.WriteLine(jack + \\\" has \\\" jack.HowManyNames() + \\\" names.\\\");\\n  Console.WriteLine(mike + \\\" has \\\" mike.HowManyNames() + \\\" names.\\\");\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-console\"\n  }, \"Ada Lovelace has 2 names.\\nJack The Ripper has 3 names.\\nMike The Incredible Magic Mouse has 5 names.\\n\")), mdx(Note, {\n    mdxType: \"Note\"\n  }, \"Console.WriteLine kutsutaan metodin sis\\xE4lt\\xE4 t\\xE4ll\\xE4 kertaa!\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#luokkien-ja-olioiden-metodit-staattisuus","title":"Luokkien ja olioiden metodit: staattisuus","items":[{"url":"#oliot-luokkametodin-parametrina","title":"Oliot luokkametodin parametrina"},{"url":"#milloin-tulisi-käyttää-luokkametodeja","title":"Milloin tulisi käyttää luokkametodeja"}]},{"url":"#tehtävät","title":"Tehtävät"}]},"frontmatter":{"title":"Staattisuus ja ei-staattisuus"}}},"pageContext":{"id":"b6f62bfa-367c-52f3-873d-9397fcb2a2ef"}},
    "staticQueryHashes": ["1885717130","1950529541","2744905544","3020054368"]}